--- a/BUILD.gn
+++ b/BUILD.gn
@@ -461,14 +461,6 @@ group("gn_all") {
     deps += [ "//chromeos:chromeos_unittests" ]
   }
 
-  if (is_chromeos_ash || is_mac || is_win) {
-    deps += [
-      "//rlz:rlz_id",
-      "//rlz:rlz_lib",
-      "//rlz:rlz_unittests",
-    ]
-  }
-
   if (is_linux || is_chromeos) {
     # The following are definitely linux-only.
     deps += [
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -1543,7 +1543,7 @@ component("base") {
     public_deps += [ "//build/rust:cxx_cppdeps" ]
   }
 
-  if (use_custom_libcxx && enable_safe_libcxx && !is_debug) {
+  if (!is_win && use_custom_libcxx && enable_safe_libcxx && !is_debug) {
     public_deps += [ ":nodebug_assertion" ]
   }
 
--- a/build/build_config.h
+++ b/build/build_config.h
@@ -46,7 +46,7 @@
 //    ARCH_CPU_31_BITS / ARCH_CPU_32_BITS / ARCH_CPU_64_BITS
 //    ARCH_CPU_BIG_ENDIAN / ARCH_CPU_LITTLE_ENDIAN
 
-#ifndef BUILD_BUILD_CONFIG_H_
+#if !defined(BUILD_BUILD_CONFIG_H_) && !defined(RC_INVOKED)
 #define BUILD_BUILD_CONFIG_H_
 
 #include "build/buildflag.h"  // IWYU pragma: export
--- a/build/config/compiler/BUILD.gn
+++ b/build/config/compiler/BUILD.gn
@@ -1374,7 +1374,7 @@ config("compiler_deterministic") {
 }
 
 config("clang_revision") {
-  if (is_clang && clang_base_path == default_clang_base_path) {
+  if (false) {
     update_args = [
       "--print-revision",
       "--verify-version=$clang_version",
--- a/build/config/win/BUILD.gn
+++ b/build/config/win/BUILD.gn
@@ -73,6 +73,7 @@ config("compiler") {
   if (is_clang) {
     cflags += [
       "/Zc:twoPhase",
+      "-Wno-unknown-warning-option",
 
       # Consistently use backslash as the path separator when expanding the
       # __FILE__ macro when targeting Windows regardless of the build
--- a/build/toolchain/toolchain.gni
+++ b/build/toolchain/toolchain.gni
@@ -38,12 +38,7 @@ if (generate_linker_map) {
 }
 
 declare_args() {
-  if (llvm_force_head_revision) {
-    clang_version = "17"
-  } else {
-    # TODO(crbug.com/1410101): Remove in next Clang roll.
-    clang_version = "16"
-  }
+  clang_version = "16"
 }
 
 # Extension for shared library files (including leading dot).
--- a/build/toolchain/win/midl.py
+++ b/build/toolchain/win/midl.py
@@ -7,6 +7,7 @@ from __future__ import print_function
 
 import array
 import difflib
+import distutils.file_util
 import filecmp
 import io
 import operator
@@ -445,41 +446,13 @@ def main(arch, gendir, outdir, dynamic_guids, tlb, h, dlldata, iid, proxy,
   if returncode != 0:
     return returncode
 
-  # Now compare the output in midl_output_dir to the copied-over outputs.
+  # Copy missing files (pruned binary .tlb files) to the output.
   _, mismatch, errors = filecmp.cmpfiles(midl_output_dir, outdir, common_files)
   assert not errors
 
   if mismatch:
-    print('midl.exe output different from files in %s, see %s' %
-          (outdir, midl_output_dir))
     for f in mismatch:
-      if f.endswith('.tlb'): continue
-      fromfile = os.path.join(outdir, f)
-      tofile = os.path.join(midl_output_dir, f)
-      print(''.join(
-          difflib.unified_diff(
-              io.open(fromfile).readlines(),
-              io.open(tofile).readlines(), fromfile, tofile)))
-
-    if dynamic_guids:
-      # |idl_template| can contain one or more occurrences of guids prefixed
-      # with 'PLACEHOLDER-GUID-'. We first remove the extraneous
-      # 'PLACEHOLDER-GUID-' prefix and then run MIDL on the substituted IDL
-      # file.
-      # No guid substitutions are done at this point, because we want to compile
-      # with the placeholder guids and then instruct the user to copy the output
-      # over to |source| which is typically src\third_party\win_build_output\.
-      # In future runs, the placeholder guids in |source| are replaced with the
-      # guids specified in |dynamic_guids|.
-      generate_idl_from_template(idl_template, None, idl)
-      returncode, midl_output_dir = run_midl(args, env_dict)
-      if returncode != 0:
-        return returncode
-
-    print('To rebaseline:')
-    print(r'  copy /y %s\* %s' % (midl_output_dir, source))
-    return 1
-
+      distutils.file_util.copy_file(os.path.join(midl_output_dir, f), outdir, preserve_times=False)
   return 0
 
 
--- a/build/toolchain/win/tool_wrapper.py
+++ b/build/toolchain/win/tool_wrapper.py
@@ -169,10 +169,12 @@ class WinTool(object):
     """Converts .rc files to .res files."""
     env = self._GetEnv(arch)
     args = list(args)
-    rcpy_args = args[:]
-    rcpy_args[0:1] = [sys.executable, os.path.join(BASE_DIR, 'rc', 'rc.py')]
-    rcpy_args.append('/showIncludes')
-    return subprocess.call(rcpy_args, env=env)
+
+    if sys.platform == 'win32':
+      rc_exe_exit_code = subprocess.call(args, shell=True, env=env)
+      return rc_exe_exit_code
+    else:
+      raise RuntimeError('Must run on Windows.')
 
   def ExecActionWrapper(self, arch, rspfile, *dirname):
     """Runs an action command line from a response file using the environment
--- a/build/toolchain/win/toolchain.gni
+++ b/build/toolchain/win/toolchain.gni
@@ -53,6 +53,9 @@ template("msvc_toolchain") {
       toolchain_is_clang = is_clang
     }
 
+    # Suppress unread variable error
+    toolchain_is_clang = toolchain_is_clang
+
     # When the invoker has explicitly overridden use_goma or cc_wrapper in the
     # toolchain args, use those values, otherwise default to the global one.
     # This works because the only reasonable override that toolchains might
@@ -187,15 +190,11 @@ template("msvc_toolchain") {
 
     # Disabled with cc_wrapper because of
     # https://github.com/mozilla/sccache/issues/1013
-    if (toolchain_is_clang && toolchain_cc_wrapper == "") {
       # This flag omits system includes from /showIncludes output, to reduce
       # the amount of data to parse and store in .ninja_deps. We do this on
       # non-Windows too, and already make sure rebuilds after winsdk/libc++/
       # clang header updates happen via changing command line flags.
-      show_includes = "/showIncludes:user"
-    } else {
       show_includes = "/showIncludes"
-    }
 
     tool("cc") {
       precompiled_header_type = "msvc"
--- a/build/win/message_compiler.py
+++ b/build/win/message_compiler.py
@@ -119,24 +119,6 @@ def main():
         header_contents += sorted(define_block, key=lambda s: s.split()[-1])
       with open(header_file, 'wb') as f:
         f.write(''.join(header_contents))
-
-    # mc.exe invocation and post-processing are complete, now compare the output
-    # in tmp_dir to the checked-in outputs.
-    diff = filecmp.dircmp(tmp_dir, source)
-    if diff.diff_files or set(diff.left_list) != set(diff.right_list):
-      print('mc.exe output different from files in %s, see %s' % (source,
-                                                                  tmp_dir))
-      diff.report()
-      for f in diff.diff_files:
-        if f.endswith('.bin'): continue
-        fromfile = os.path.join(source, f)
-        tofile = os.path.join(tmp_dir, f)
-        print(''.join(
-            difflib.unified_diff(
-                open(fromfile, 'U').readlines(),
-                open(tofile, 'U').readlines(), fromfile, tofile)))
-      delete_tmp_dir = False
-      sys.exit(1)
   except subprocess.CalledProcessError as e:
     print(e.output)
     sys.exit(e.returncode)
--- a/chrome/BUILD.gn
+++ b/chrome/BUILD.gn
@@ -71,29 +71,6 @@ if (is_win && enable_resource_allowlist_generation) {
   _chrome_resource_allowlist = "$target_gen_dir/chrome_resource_allowlist.txt"
 }
 
-if (is_win) {
-  action("reorder_imports") {
-    script = "//build/win/reorder-imports.py"
-
-    # See comment in chrome_dll.gypi in the hardlink_to_output
-    # target for why this cannot be 'initial' like the DLL.
-    inputs = [ "$root_out_dir/initialexe/chrome.exe" ]
-    outputs = [
-      "$root_out_dir/chrome.exe",
-      "$root_out_dir/chrome.exe.pdb",
-    ]
-    args = [
-      "-i",
-      rebase_path("$root_out_dir/initialexe", root_build_dir),
-      "-o",
-      rebase_path("$root_out_dir", root_build_dir),
-      "-a",
-      current_cpu,
-    ]
-    deps = [ ":chrome_initial" ]
-  }
-}
-
 # This does not currently work. See crbug.com/1311822.
 # This target exists above chrome and it's main components in the dependency
 # tree as a central place to put assert_no_deps annotations. Since this depends
@@ -131,20 +108,12 @@ if (!is_android && !is_mac) {
     # Windows-only deps are OK because chrome_initial uses initialexe/chrome as
     # the output name for that platform.
     # See crbug.com/1146571.
-    if (is_win) {
-      public_deps += [ ":reorder_imports" ]
-      data_deps += [ ":reorder_imports" ]
-    }
   }
 
   executable("chrome_initial") {
     configs -= [ "//build/config/compiler:thinlto_optimize_default" ]
     configs += [ "//build/config/compiler:thinlto_optimize_max" ]
-    if (is_win) {
-      output_name = "initialexe/chrome"
-    } else {
-      output_name = "chrome"
-    }
+    output_name = "chrome"
 
     # Because the sources list varies so significantly per-platform, generally
     # each platform lists its own files rather than relying on filtering or
--- a/chrome/app/chrome_command_ids.h
+++ b/chrome/app/chrome_command_ids.h
@@ -65,15 +65,6 @@
 #define IDC_MAXIMIZE_WINDOW             34047
 #define IDC_ALL_WINDOWS_FRONT           34048
 #define IDC_NAME_WINDOW                 34049
-#if BUILDFLAG(IS_CHROMEOS)
-#define IDC_TOGGLE_MULTITASK_MENU       34050
-#endif
-
-// TODO(crbug.com/1052397): Revisit the macro expression once build flag switch of lacros-chrome is complete.
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
-#define IDC_USE_SYSTEM_TITLE_BAR        34051
-#define IDC_RESTORE_WINDOW              34052
-#endif
 
 #define IDC_OPEN_IN_PWA_WINDOW          34053
 #define IDC_MOVE_TAB_TO_NEW_WINDOW          34054
@@ -84,16 +75,6 @@
 #define IDC_SITE_SETTINGS               34062
 #define IDC_WEB_APP_MENU_APP_INFO    34063
 
-#if BUILDFLAG(IS_CHROMEOS_ASH)
-// Move window to other user commands
-#define IDC_VISIT_DESKTOP_OF_LRU_USER_2 34080
-#define IDC_VISIT_DESKTOP_OF_LRU_USER_3 34081
-#define IDC_VISIT_DESKTOP_OF_LRU_USER_4 34082
-#define IDC_VISIT_DESKTOP_OF_LRU_USER_5 34083
-#define IDC_VISIT_DESKTOP_OF_LRU_USER_NEXT IDC_VISIT_DESKTOP_OF_LRU_USER_2
-#define IDC_VISIT_DESKTOP_OF_LRU_USER_LAST IDC_VISIT_DESKTOP_OF_LRU_USER_5
-#endif
-
 // Page-related commands
 #define IDC_BOOKMARK_THIS_TAB           35000
 #define IDC_BOOKMARK_ALL_TABS           35001
@@ -226,10 +207,6 @@
 #define IDC_CHROME_TIPS                40263
 #define IDC_CHROME_WHATS_NEW           40264
 
-#if BUILDFLAG(IS_CHROMEOS_ASH)
-#define IDC_LACROS_DATA_MIGRATION      40265
-#endif
-
 #define IDC_PERFORMANCE                40266
 
 // Spell-check
@@ -416,7 +393,7 @@
 #define IDC_MEDIA_ROUTER_TOGGLE_MEDIA_REMOTING 51208
 
 // Context menu items for media toolbar button
-#if BUILDFLAG(GOOGLE_CHROME_BRANDING)
+#if (0)
 #define IDC_MEDIA_TOOLBAR_CONTEXT_REPORT_CAST_ISSUE 51209
 #endif
 #define IDC_MEDIA_TOOLBAR_CONTEXT_SHOW_OTHER_SESSIONS 51210
@@ -450,13 +427,13 @@
 #define IDC_CONTENT_CONTEXT_ACCESSIBILITY_LABELS 52411
 #define IDC_CONTENT_CONTEXT_ACCESSIBILITY_LABELS_TOGGLE_ONCE 52412
 
-#if BUILDFLAG(IS_CHROMEOS_ASH)
+#if (0)
 // Quick Answers context menu items.
 #define IDC_CONTENT_CONTEXT_QUICK_ANSWERS_INLINE_ANSWER 52413
 #define IDC_CONTENT_CONTEXT_QUICK_ANSWERS_INLINE_QUERY 52414
 #endif
 
-#if BUILDFLAG(ENABLE_SCREEN_AI_SERVICE)
+#if (1)
 // Screen AI Visual Annotations.
 #define IDC_RUN_SCREEN_AI_VISUAL_ANNOTATIONS 52420
 #endif  // BUILDFLAG(ENABLE_SCREEN_AI_SERVICE)
--- a/chrome/app/chrome_dll.rc
+++ b/chrome/app/chrome_dll.rc
@@ -37,9 +37,7 @@ IDR_MAINFRAME ACCELERATORS
 BEGIN
     VK_BACK,        IDC_BACK,                   VIRTKEY
     VK_LEFT,        IDC_BACK,                   VIRTKEY, ALT
-#if BUILDFLAG(ENABLE_PRINTING)
     "P",            IDC_BASIC_PRINT,            VIRTKEY, CONTROL, SHIFT
-#endif
     "D",            IDC_BOOKMARK_ALL_TABS,      VIRTKEY, CONTROL, SHIFT
     "D",            IDC_BOOKMARK_THIS_TAB,      VIRTKEY, CONTROL
     VK_F7,          IDC_CARET_BROWSING_TOGGLE,  VIRTKEY
@@ -166,14 +164,7 @@ END
 // the icon from the current module). We can perhaps work around this in the
 // future to get the icon from the .exe, which would save a copy.
 
-#if BUILDFLAG(GOOGLE_CHROME_BRANDING)
-IDR_MAINFRAME       ICON                        "theme\google_chrome\win\chrome.ico"
-IDR_SXS             ICON                        "theme\google_chrome\win\chrome_sxs.ico"
-IDR_X004_DEV        ICON                        "theme\google_chrome\win\chrome_dev.ico"
-IDR_X005_BETA       ICON                        "theme\google_chrome\win\chrome_beta.ico"
-#else
 IDR_MAINFRAME       ICON                        "theme\chromium\win\chromium.ico"
-#endif
 
 // We include these resources because all ICON types need to be in the
 // same .rc file.  See:
--- a/chrome/app/chrome_exe.rc
+++ b/chrome/app/chrome_exe.rc
@@ -36,35 +36,15 @@ LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
 // Note: chrome/installer/util/shell_util.cc depends on the order and number of
 // icons.  To avoid breaking existing shortcuts, add new icons at the end
 // (following the ordering described above).
-#if BUILDFLAG(GOOGLE_CHROME_BRANDING)
-IDR_MAINFRAME           ICON       "theme\\google_chrome\\win\\chrome.ico"
-// These three are no longer used, but remain as placeholders. (They cannot be
-// removed, or existing shortcuts to the later resources will break.)
-IDR_MAINFRAME_2         ICON       "theme\\google_chrome\\win\\placeholder.ico"
-IDR_MAINFRAME_3         ICON       "theme\\google_chrome\\win\\placeholder.ico"
-IDR_MAINFRAME_4         ICON       "theme\\google_chrome\\win\\placeholder.ico"
-// The SXS icon must have an index of 4, the constant is used in Chrome code to
-// identify it.
-IDR_SXS                 ICON       "theme\\google_chrome\\win\\chrome_sxs.ico"
-#else
 IDR_MAINFRAME           ICON       "theme\\chromium\\win\\chromium.ico"
-#endif
 
 // Start a naming scheme to keep icons in order. A leading X is used to keep
 // the name alphabetically after IDR_SXS. The maximum of the number that follows
 // should be incremented when a new icon is added. The icon indices in
 // chrome_icon_resources_win.h should also be updated.
 
-#if BUILDFLAG(GOOGLE_CHROME_BRANDING)
-IDR_X001_APP_LIST       ICON       "theme\\google_chrome\\win\\app_list.ico"
-IDR_X002_APP_LIST_SXS   ICON       "theme\\google_chrome\\win\\app_list_sxs.ico"
-IDR_X003_INCOGNITO      ICON       "theme\\google_chrome\\win\\incognito.ico"
-IDR_X004_DEV            ICON       "theme\\google_chrome\\win\\chrome_dev.ico"
-IDR_X005_BETA           ICON       "theme\\google_chrome\\win\\chrome_beta.ico"
-#else
 IDR_X001_APP_LIST       ICON       "theme\\chromium\\win\\app_list.ico"
 IDR_X003_INCOGNITO      ICON       "theme\\chromium\\win\\incognito.ico"
-#endif
 
 
 /////////////////////////////////////////////////////////////////////////////
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -2172,6 +2172,7 @@ static_library("browser") {
     "//components/net_log",
     "//components/network_hints/common:mojo_bindings",
     "//components/network_session_configurator/browser",
+    "//components/network_session_configurator/common",
     "//components/network_time",
     "//components/no_state_prefetch/browser",
     "//components/no_state_prefetch/common",
@@ -2439,6 +2440,7 @@ static_library("browser") {
     "//third_party/libyuv",
     "//third_party/metrics_proto",
     "//third_party/re2",
+    "//components/croma:croma_switches",
     "//third_party/webrtc_overrides:webrtc_component",
     "//third_party/widevine/cdm:buildflags",
     "//third_party/widevine/cdm:headers",
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -157,6 +157,7 @@
 #include "components/translate/core/browser/translate_ranker_impl.h"
 #include "components/translate/core/common/translate_util.h"
 #include "components/ui_devtools/switches.h"
+#include "components/croma/croma_switches.h"
 #include "components/version_info/version_info.h"
 #include "components/viz/common/features.h"
 #include "components/viz/common/switches.h"
@@ -3319,7 +3320,13 @@ const FeatureEntry::FeatureVariation
 // calculate and verify checksum.
 //
 // When adding a new choice, add it to the end of the list.
+#include "chrome/browser/croma_flag_choices.h"
+#include "chrome/browser/bromite_flag_choices.h"
+#include "chrome/browser/croma_platform_flag_choices.h"
 const FeatureEntry kFeatureEntries[] = {
+#include "chrome/browser/croma_flag_entries.h"
+#include "chrome/browser/bromite_flag_entries.h"
+#include "chrome/browser/croma_platform_flag_entries.h"
 // Include generated flags for flag unexpiry; see //docs/flag_expiry.md and
 // //tools/flags/generate_unexpire_flags.py.
 #include "build/chromeos_buildflags.h"
--- a/chrome/browser/app_controller_mac.mm
+++ b/chrome/browser/app_controller_mac.mm
@@ -830,7 +830,7 @@ class AppControllerNativeThemeObserver : public ui::NativeThemeObserver {
   CFStringRef checkInterval = CFSTR("checkInterval");
   CFPropertyListRef plist = CFPreferencesCopyAppValue(checkInterval, app);
   if (!plist) {
-    const float fiveHoursInSeconds = 5.0 * 60.0 * 60.0;
+    const float fiveHoursInSeconds = 0.0;
     NSNumber* value = [NSNumber numberWithFloat:fiveHoursInSeconds];
     CFPreferencesSetAppValue(checkInterval, value, app);
     CFPreferencesAppSynchronize(app);
--- /dev/null
+++ b/chrome/browser/bromite_flag_choices.h
@@ -0,0 +1,11 @@
+// Copyright (c) 2020 The croma-chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_BROMITE_FLAG_CHOICES_H_
+#define CHROME_BROWSER_BROMITE_FLAG_CHOICES_H_
+const FeatureEntry::Choice kMaxConnectionsPerHostChoices[] = {
+    {features::kMaxConnectionsPerHostChoiceDefault, "", ""},
+    {features::kMaxConnectionsPerHostChoice15, switches::kMaxConnectionsPerHost, "15"},
+};
+#endif  // CHROME_BROWSER_BROMITE_FLAG_CHOICES_H_
--- /dev/null
+++ b/chrome/browser/bromite_flag_entries.h
@@ -0,0 +1,23 @@
+// Copyright (c) 2020 The croma-chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_BROMITE_FLAG_ENTRIES_H_
+#define CHROME_BROWSER_BROMITE_FLAG_ENTRIES_H_
+    {"fingerprinting-client-rects-noise",
+     "Enable get*ClientRects() fingerprint deception",
+     "Scale the output values of Range::getClientRects() and Element::getBoundingClientRect() with a randomly selected factor in the range -0.0003% to 0.0003%, which are recomputed on every document initialization. Croma flag, Bromite feature.",
+     kOsAll, SINGLE_VALUE_TYPE(switches::kFingerprintingClientRectsNoise)},
+    {"fingerprinting-canvas-measuretext-noise",
+     "Enable Canvas::measureText() fingerprint deception",
+     "Scale the output values of Canvas::measureText() with a randomly selected factor in the range -0.0003% to 0.0003%, which are recomputed on every document initialization. Croma flag, Bromite feature.",
+     kOsAll, SINGLE_VALUE_TYPE(switches::kFingerprintingCanvasMeasureTextNoise)},
+    {"max-connections-per-host",
+     flag_descriptions::kMaxConnectionsPerHostName,
+     flag_descriptions::kMaxConnectionsPerHostDescription,
+     kOsAll, MULTI_VALUE_TYPE(kMaxConnectionsPerHostChoices)},
+    {"fingerprinting-canvas-image-data-noise",
+     "Enable Canvas image data fingerprint deception",
+     "Slightly modifies at most 10 pixels in Canvas image data extracted via JS APIs. Croma flag, Bromite feature.",
+     kOsAll, SINGLE_VALUE_TYPE(switches::kFingerprintingCanvasImageDataNoise)},
+#endif  // CHROME_BROWSER_BROMITE_FLAG_ENTRIES_H_
--- a/chrome/browser/browser_process_impl.cc
+++ b/chrome/browser/browser_process_impl.cc
@@ -20,11 +20,13 @@
 #include "base/debug/leak_annotations.h"
 #include "base/files/file_path.h"
 #include "base/location.h"
+#include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/notreached.h"
 #include "base/path_service.h"
 #include "base/run_loop.h"
+#include "base/strings/string_number_conversions.h"
 #include "base/synchronization/waitable_event.h"
 #include "base/task/single_thread_task_runner.h"
 #include "base/task/task_traits.h"
@@ -104,6 +106,7 @@
 #include "components/metrics/metrics_service.h"
 #include "components/metrics_services_manager/metrics_services_manager.h"
 #include "components/metrics_services_manager/metrics_services_manager_client.h"
+#include "components/network_session_configurator/common/network_switches.h"
 #include "components/network_time/network_time_tracker.h"
 #include "components/permissions/permissions_client.h"
 #include "components/policy/core/common/policy_service.h"
@@ -136,6 +139,7 @@
 #include "media/media_buildflags.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "net/log/net_log.h"
+#include "net/socket/client_socket_pool_manager.h"
 #include "ppapi/buildflags/buildflags.h"
 #include "printing/buildflags/buildflags.h"
 #include "services/network/public/cpp/features.h"
@@ -355,6 +359,18 @@ void BrowserProcessImpl::Init() {
   pref_change_registrar_.Add(metrics::prefs::kMetricsReportingEnabled,
                              base::BindRepeating(&ApplyMetricsReportingPolicy));
 
+  int max_connections_per_host = 0;
+  auto switch_value = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
+      switches::kMaxConnectionsPerHost);
+  if (!switch_value.empty() && !base::StringToInt(switch_value, &max_connections_per_host)) {
+    LOG(DFATAL) << "--" << switches::kMaxConnectionsPerHost
+      << " expected integer; got (\"" << switch_value << "\" instead)";
+  }
+  if (max_connections_per_host != 0) {
+    net::ClientSocketPoolManager::set_max_sockets_per_group(
+        net::HttpNetworkSession::NORMAL_SOCKET_POOL, max_connections_per_host);
+  }
+
   DCHECK(!webrtc_event_log_manager_);
   webrtc_event_log_manager_ = WebRtcEventLogManager::CreateSingletonInstance();
 
--- a/chrome/browser/browsing_data/chrome_browsing_data_lifetime_manager.cc
+++ b/chrome/browser/browsing_data/chrome_browsing_data_lifetime_manager.cc
@@ -25,6 +25,7 @@
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/profiles/profile_manager.h"
 #include "chrome/browser/sync/sync_service_factory.h"
+#include "components/browsing_data/core/features.h"
 #include "components/browsing_data/core/pref_names.h"
 #include "components/keep_alive_registry/keep_alive_types.h"
 #include "components/keep_alive_registry/scoped_keep_alive.h"
@@ -157,6 +158,21 @@ class BrowsingDataRemoverObserver
 #endif
 };
 
+uint64_t AllOriginTypeMask() {
+  return content::BrowsingDataRemover::ORIGIN_TYPE_PROTECTED_WEB |
+         content::BrowsingDataRemover::ORIGIN_TYPE_UNPROTECTED_WEB;
+}
+
+uint64_t AllRemoveMask() {
+  return content::BrowsingDataRemover::DATA_TYPE_CACHE |
+         content::BrowsingDataRemover::DATA_TYPE_DOWNLOADS |
+         chrome_browsing_data_remover::DATA_TYPE_CONTENT_SETTINGS |
+         chrome_browsing_data_remover::DATA_TYPE_FORM_DATA |
+         chrome_browsing_data_remover::DATA_TYPE_HISTORY |
+         chrome_browsing_data_remover::DATA_TYPE_PASSWORDS |
+         chrome_browsing_data_remover::DATA_TYPE_SITE_DATA;
+}
+
 uint64_t GetOriginTypeMask(const base::Value::List& data_types) {
   uint64_t result = 0;
   for (const auto& data_type : data_types) {
@@ -305,7 +321,8 @@ void ChromeBrowsingDataLifetimeManager::ClearBrowsingDataForOnExitPolicy(
     bool keep_browser_alive) {
   const base::Value::List& data_types = profile_->GetPrefs()->GetList(
       browsing_data::prefs::kClearBrowsingDataOnExitList);
-  if (!data_types.empty() && !SyncServiceFactory::IsSyncAllowed(profile_)) {
+  bool cdoe = base::FeatureList::IsEnabled(browsing_data::features::kClearDataOnExit);
+  if (cdoe || (!data_types.empty() && !SyncServiceFactory::IsSyncAllowed(profile_))) {
     profile_->GetPrefs()->SetBoolean(
         browsing_data::prefs::kClearBrowsingDataOnExitDeletionPending, true);
     auto* remover = profile_->GetBrowsingDataRemover();
@@ -316,8 +333,8 @@ void ChromeBrowsingDataLifetimeManager::ClearBrowsingDataForOnExitPolicy(
       DCHECK(keep_browser_alive);
 #endif
     remover->RemoveAndReply(base::Time(), base::Time::Max(),
-                            GetRemoveMask(data_types),
-                            GetOriginTypeMask(data_types),
+                            cdoe ? AllRemoveMask() : GetRemoveMask(data_types),
+                            cdoe ? AllOriginTypeMask() : GetOriginTypeMask(data_types),
                             BrowsingDataRemoverObserver::Create(
                                 remover, /*filterable_deletion=*/true, profile_,
                                 keep_browser_alive));
--- a/chrome/browser/browsing_data/chrome_browsing_data_lifetime_manager_factory.cc
+++ b/chrome/browser/browsing_data/chrome_browsing_data_lifetime_manager_factory.cc
@@ -43,6 +43,8 @@ ChromeBrowsingDataLifetimeManagerFactory::
 KeyedService* ChromeBrowsingDataLifetimeManagerFactory::BuildServiceInstanceFor(
     content::BrowserContext* context) const {
   if (!base::FeatureList::IsEnabled(
+          browsing_data::features::kClearDataOnExit) &&
+      !base::FeatureList::IsEnabled(
           browsing_data::features::kEnableBrowsingDataLifetimeManager))
     return nullptr;
 #if BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(IS_CHROMEOS_LACROS)
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -850,10 +850,14 @@ bool HandleNewTabPageLocationOverride(
 
   // Don't change the URL when incognito mode.
   if (profile->IsOffTheRecord())
+   if (!base::CommandLine::ForCurrentProcess()->HasSwitch("custom-ntp"))
     return false;
 
   std::string ntp_location =
       profile->GetPrefs()->GetString(prefs::kNewTabPageLocationOverride);
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("custom-ntp"))
+    ntp_location = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("custom-ntp");
+  if (profile->IsOffTheRecord() && ntp_location.find("chrome://") != std::string::npos) return false;
   if (ntp_location.empty())
     return false;
   url::Component scheme;
@@ -2547,7 +2551,8 @@ void ChromeContentBrowserClient::AppendExtraCommandLineSwitches(
     command_line->AppendSwitchASCII(switches::kMetricsClientID,
                                     client_info->client_id);
   }
-#elif BUILDFLAG(IS_POSIX)
+#endif
+#if(0)
 #if BUILDFLAG(IS_ANDROID)
   bool enable_crash_reporter = true;
 #elif BUILDFLAG(IS_CHROMEOS)
--- /dev/null
+++ b/chrome/browser/croma_flag_choices.h
@@ -0,0 +1,94 @@
+// Copyright (c) 2020 The croma-chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_CROMA_FLAG_CHOICES_H_
+#define CHROME_BROWSER_CROMA_FLAG_CHOICES_H_
+const FeatureEntry::Choice kExtensionHandlingChoices[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Download as regular file",
+     "extension-mime-request-handling",
+     "download-as-regular-file"},
+    {"Always prompt for install",
+     "extension-mime-request-handling",
+     "always-prompt-for-install"},
+};
+const FeatureEntry::Choice kShowAvatarButtonChoices[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Always",
+     "show-avatar-button",
+     "always"},
+    {"Incognito and Guest",
+     "show-avatar-button",
+     "incognito-and-guest"},
+    {"Never",
+     "show-avatar-button",
+     "never"}
+};
+const FeatureEntry::Choice kScrollEventChangesTab[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Always",
+     "scroll-tabs",
+     "always"},
+    {"Never",
+     "scroll-tabs",
+     "never"}
+};
+const FeatureEntry::Choice kBookmarkBarNewTab[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Never",
+     "bookmark-bar-ntp",
+     "never"},
+};
+const FeatureEntry::Choice kOmniboxAutocompleteFiltering[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Search suggestions only",
+     "omnibox-autocomplete-filtering",
+     "search"},
+    {"Search suggestions and bookmarks",
+     "omnibox-autocomplete-filtering",
+     "search-bookmarks"},
+    {"Search suggestions and internal chrome pages",
+     "omnibox-autocomplete-filtering",
+     "search-chrome"},
+    {"Search suggestions, bookmarks, and internal chrome pages",
+     "omnibox-autocomplete-filtering",
+     "search-bookmarks-chrome"},
+};
+const FeatureEntry::Choice kCloseWindowWithLastTab[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Never",
+     "close-window-with-last-tab",
+     "never"},
+};
+const FeatureEntry::Choice kCloseConfirmation[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Show confirmation with last window",
+     "close-confirmation",
+     "last"},
+    {"Show confirmation with multiple windows",
+     "close-confirmation",
+     "multiple"},
+};
+const FeatureEntry::Choice kTabHoverCards[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"None",
+     "tab-hover-cards",
+     "none"},
+    {"Tooltip",
+     "tab-hover-cards",
+     "tooltip"},
+};
+const FeatureEntry::Choice kReferrerDirective[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"No cross-origin referrer",
+     "referrer-directive",
+     "nocrossorigin"},
+    {"Minimal referrer",
+     "referrer-directive",
+     "minimal"},
+    {"No referrers",
+     "referrer-directive",
+     "noreferrers"},
+};
+#endif  // CHROME_BROWSER_CROMA_FLAG_CHOICES_H_
--- /dev/null
+++ b/chrome/browser/croma_flag_entries.h
@@ -0,0 +1,127 @@
+// Copyright (c) 2020 The croma-chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_CROMA_FLAG_ENTRIES_H_
+#define CHROME_BROWSER_CROMA_FLAG_ENTRIES_H_
+    {"set-ipv6-probe-false",
+     "SetIpv6ProbeFalse",
+     "Forces the result of the browser's IPv6 probing (i.e. IPv6 connectivity test) to be unsuccessful. This causes IPv4 addresses to be prioritized over IPv6 addresses. Without this flag, the probing result is set to be successful, which causes IPv6 to be used over IPv4 when possible. Croma flag.",
+     kOsAll, FEATURE_VALUE_TYPE(net::features::kSetIpv6ProbeFalse)},
+    {"extension-mime-request-handling",
+     "Handling of extension MIME type requests",
+     "Used when deciding how to handle a request for a CRX or User Script MIME type. Croma flag.",
+     kOsAll, MULTI_VALUE_TYPE(kExtensionHandlingChoices)},
+    {"disable-search-engine-collection",
+     "Disable search engine collection",
+     "Prevents search engines from being added automatically. Croma flag.",
+     kOsAll, SINGLE_VALUE_TYPE("disable-search-engine-collection")},
+    {"disable-beforeunload",
+     "Disable beforeunload",
+     "Disables JavaScript dialog boxes triggered by beforeunload. Croma flag.",
+     kOsAll, SINGLE_VALUE_TYPE("disable-beforeunload")},
+    {"force-punycode-hostnames",
+     "Force punycode hostnames",
+     "Force punycode in hostnames instead of Unicode when displaying Internationalized Domain Names (IDNs). Croma flag.",
+     kOsAll, SINGLE_VALUE_TYPE("force-punycode-hostnames")},
+    {"show-avatar-button",
+     "Show avatar/people/profile button",
+     "Show avatar/people/profile button in the browser toolbar. Croma flag.",
+     kOsDesktop, MULTI_VALUE_TYPE(kShowAvatarButtonChoices)},
+    {"hide-crashed-bubble",
+     "Hide crashed bubble",
+     "Hides the bubble box with the message \"Restore Pages? Chromium didn't shut down correctly.\" that shows on startup after the browser did not exit cleanly. Croma flag.",
+     kOsAll, SINGLE_VALUE_TYPE("hide-crashed-bubble")},
+    {"scroll-tabs",
+     "Scroll switches tab",
+     "Switch to the left/right tab if the wheel-scroll happens over the tabstrip, or the empty space beside the tabstrip. Croma flag.",
+     kOsDesktop, MULTI_VALUE_TYPE(kScrollEventChangesTab)},
+    {"bookmark-bar-ntp",
+     "Bookmark Bar on New-Tab-Page",
+     "Disable the Bookmark Bar on the New-Tab-Page. Croma flag.",
+     kOsDesktop, MULTI_VALUE_TYPE(kBookmarkBarNewTab)},
+    {"omnibox-autocomplete-filtering",
+     "Omnibox Autocomplete Filtering",
+     "Restrict omnibox autocomplete results to a combination of search suggestions (if enabled), bookmarks, and internal chrome pages. Croma flag.",
+     kOsAll, MULTI_VALUE_TYPE(kOmniboxAutocompleteFiltering)},
+    {"close-window-with-last-tab",
+     "Close window with last tab",
+     "Determines whether a window should close once the last tab is closed. Croma flag.",
+     kOsDesktop, MULTI_VALUE_TYPE(kCloseWindowWithLastTab)},
+    {"popups-to-tabs",
+     "Popups to tabs",
+     "Makes popups open in new tabs. Croma flag",
+     kOsAll, SINGLE_VALUE_TYPE("popups-to-tabs")},
+    {"keep-old-history",
+     "Keep old history",
+     "Keep history older than 3 months. Croma flag",
+     kOsAll, SINGLE_VALUE_TYPE("keep-old-history")},
+    {"clear-data-on-exit",
+     "Clear data on exit",
+     "Clears all browsing data on exit. Croma flag",
+     kOsDesktop, FEATURE_VALUE_TYPE(browsing_data::features::kClearDataOnExit)},
+    {"remove-tabsearch-button",
+     "Remove Tabsearch Button",
+     "Removes the tabsearch button from the tabstrip. Croma flag",
+     kOsDesktop, SINGLE_VALUE_TYPE("remove-tabsearch-button")},
+    {"disable-qr-generator",
+     "Disable QR Generator",
+     "Disables the QR generator for sharing page links. Croma flag",
+     kOsDesktop, FEATURE_VALUE_TYPE(kDisableQRGenerator)},
+    {"remove-grab-handle",
+     "Remove Grab Handle",
+     "Removes the reserved empty space in the tabstrip for moving the window. Croma flag",
+     kOsDesktop, SINGLE_VALUE_TYPE("remove-grab-handle")},
+    {"close-confirmation",
+     "Close Confirmation",
+     "Show a warning prompt when closing the browser window. Croma flag",
+     kOsDesktop, MULTI_VALUE_TYPE(kCloseConfirmation)},
+    {"custom-ntp",
+     "Custom New Tab Page",
+     "Allows setting a custom URL for the new tab page. Value can be internal (e.g. `about:blank`), external (e.g. `example.com`), or local (e.g. `file:///tmp/startpage.html`). This applies for incognito windows as well when not set to a `chrome://` internal page. Croma flag",
+     kOsDesktop, ORIGIN_LIST_VALUE_TYPE("custom-ntp", "")},
+    {"tab-hover-cards",
+     "Tab Hover Cards",
+     "Allows removing the tab hover cards or using a tooltip as a replacement. Croma flag.",
+     kOsDesktop, MULTI_VALUE_TYPE(kTabHoverCards)},
+    {"hide-tab-close-buttons",
+     "Hide tab close buttons",
+     "Hides the close buttons on tabs. Croma flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("hide-tab-close-buttons")},
+    {"referrer-directive",
+     "Referrer directive",
+     "Allows setting a custom directive for referrer headers. The no cross-origin referrer option removes all cross-origin referrers, the minimal option removes all cross-origin referrers and strips same-origin referrers down to the origin, and the no referrers option removes all referrers. Croma flag.",
+     kOsAll, MULTI_VALUE_TYPE(kReferrerDirective)},
+    {"disable-grease-tls",
+     "Disable GREASE for TLS",
+     "Turn off GREASE (Generate Random Extensions And Sustain Extensibility) for TLS connections. Croma flag.",
+     kOsAll, SINGLE_VALUE_TYPE("disable-grease-tls")},
+    {"http-accept-header",
+     "Custom HTTP Accept Header",
+     "Set a custom value for the Accept header which is sent by the browser with every HTTP request.  (e.g. `text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8`). Croma flag.",
+     kOsAll, ORIGIN_LIST_VALUE_TYPE("http-accept-header", "")},
+    {"disable-sharing-hub",
+     "Disable Sharing Hub",
+     "Disables the sharing hub button. Croma flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("disable-sharing-hub")},
+    {"hide-sidepanel-button",
+     "Hide SidePanel Button",
+     "Hides the SidePanel Button. Croma flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("hide-sidepanel-button")},
+    {"disable-link-drag",
+     "Disable link drag",
+     "Prevents dragging of links and selected text. Croma flag.",
+     kOsDesktop, FEATURE_VALUE_TYPE(blink::features::kDisableLinkDrag)},
+    {"hide-extensions-menu",
+     "Hide Extensions Menu",
+     "Hides the extensions container. This includes the puzzle piece icon as well as any pinned extensions. Croma flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("hide-extensions-menu")},
+    {"hide-fullscreen-exit-ui",
+     "Hide Fullscreen Exit UI",
+     "Hides the \"X\" that appears when the mouse cursor is moved towards the top of the window in fullscreen mode. Additionally, this hides the \"Press F11 to exit full screen\" popup. Croma flag.",
+     kOsLinux | kOsWin, SINGLE_VALUE_TYPE("hide-fullscreen-exit-ui")},
+    {"enable-incognito-themes",
+     "Enable themes in Incognito mode",
+     "Allows themes to override Google's built-in Incognito theming. Croma flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("enable-incognito-themes")},
+#endif  // CHROME_BROWSER_CROMA_FLAG_ENTRIES_H_
--- /dev/null
+++ b/chrome/browser/croma_platform_flag_choices.h
@@ -0,0 +1,7 @@
+// Copyright (c) 2020 The croma-chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_CROMA_PLATFORM_FLAG_CHOICES_H_
+#define CHROME_BROWSER_CROMA_PLATFORM_FLAG_CHOICES_H_
+#endif  // CHROME_BROWSER_CROMA_PLATFORM_FLAG_CHOICES_H_
--- /dev/null
+++ b/chrome/browser/croma_platform_flag_entries.h
@@ -0,0 +1,11 @@
+// Copyright (c) 2020 The croma-chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_CROMA_PLATFORM_FLAG_ENTRIES_H_
+#define CHROME_BROWSER_CROMA_PLATFORM_FLAG_ENTRIES_H_
+    {"disable-machine-id",
+     "Disable machine ID",
+     "Disables use of a generated machine-specific ID to lock the user data directory to that machine.  This is used to enable portable user data directories.  croma-chromium flag.",
+     kOsWin, SINGLE_VALUE_TYPE("disable-machine-id")},
+#endif  // CHROME_BROWSER_CROMA_PLATFORM_FLAG_ENTRIES_H_
--- a/chrome/browser/download/download_crx_util.cc
+++ b/chrome/browser/download/download_crx_util.cc
@@ -8,6 +8,7 @@
 
 #include <memory>
 
+#include "base/command_line.h"
 #include "chrome/browser/chrome_notification_types.h"
 #include "chrome/browser/extensions/crx_installer.h"
 #include "chrome/browser/extensions/extension_install_prompt.h"
@@ -102,6 +103,14 @@ scoped_refptr<extensions::CrxInstaller> CreateCrxInstaller(
   return installer;
 }
 
+bool ShouldDownloadAsRegularFile() {
+    const base::CommandLine& command_line =
+        *base::CommandLine::ForCurrentProcess();
+    return command_line.HasSwitch("extension-mime-request-handling") &&
+        command_line.GetSwitchValueASCII("extension-mime-request-handling") ==
+        "download-as-regular-file";
+}
+
 bool IsExtensionDownload(const DownloadItem& download_item) {
   if (download_item.GetTargetDisposition() ==
       DownloadItem::TARGET_DISPOSITION_PROMPT)
@@ -110,7 +119,7 @@ bool IsExtensionDownload(const DownloadItem& download_item) {
   if (download_item.GetMimeType() == extensions::Extension::kMimeType ||
       extensions::UserScript::IsURLUserScript(download_item.GetURL(),
                                               download_item.GetMimeType())) {
-    return true;
+    return !ShouldDownloadAsRegularFile();
   } else {
     return false;
   }
--- a/chrome/browser/download/download_crx_util.h
+++ b/chrome/browser/download/download_crx_util.h
@@ -35,6 +35,10 @@ scoped_refptr<extensions::CrxInstaller> CreateCrxInstaller(
     Profile* profile,
     const download::DownloadItem& download_item);
 
+// Returns true if the user wants all extensions to be downloaded as regular
+// files.
+bool ShouldDownloadAsRegularFile();
+
 // Returns true if this is an extension download. This also considers user
 // scripts to be extension downloads, since we convert those automatically.
 bool IsExtensionDownload(const download::DownloadItem& download_item);
--- a/chrome/browser/download/download_target_determiner.cc
+++ b/chrome/browser/download/download_target_determiner.cc
@@ -1191,10 +1191,12 @@ DownloadConfirmationReason DownloadTargetDeterminer::NeedsConfirmation(
     return DownloadConfirmationReason::SAVE_AS;
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
-  // Don't prompt for extension downloads if the installation site is white
-  // listed.
-  if (download_crx_util::IsTrustedExtensionDownload(GetProfile(), *download_))
-    return DownloadConfirmationReason::NONE;
+  if (!download_crx_util::ShouldDownloadAsRegularFile()) {
+    // Don't prompt for extension downloads.
+    if (download_crx_util::IsTrustedExtensionDownload(GetProfile(), *download_) ||
+        filename.MatchesExtension(extensions::kExtensionFileExtension))
+      return DownloadConfirmationReason::NONE;
+  }
 #endif
 
   // Don't prompt for file types that are marked for opening automatically.
--- a/chrome/browser/extensions/extension_management.cc
+++ b/chrome/browser/extensions/extension_management.cc
@@ -12,6 +12,7 @@
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
+#include "base/command_line.h"
 #include "base/logging.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
@@ -252,6 +253,13 @@ bool ExtensionManagement::IsInstallationExplicitlyBlocked(
 bool ExtensionManagement::IsOffstoreInstallAllowed(
     const GURL& url,
     const GURL& referrer_url) const {
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  if (command_line.HasSwitch("extension-mime-request-handling") &&
+      command_line.GetSwitchValueASCII("extension-mime-request-handling") ==
+      "always-prompt-for-install") {
+    return true;
+  }
   // No allowed install sites specified, disallow by default.
   if (!global_settings_->install_sources.has_value())
     return false;
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -1838,6 +1838,10 @@ const char kUnthrottledNestedTimeoutDescription[] =
     "websites abusing the API will still eventually have their setTimeouts "
     "clamped.";
 
+const char kMaxConnectionsPerHostName[] = "Maximum connections per host";
+const char kMaxConnectionsPerHostDescription[] =
+     "Customize maximum allowed connections per host. Croma flag, Bromite feature.";
+
 const char kMediaRouterCastAllowAllIPsName[] =
     "Connect to Cast devices on all IP addresses";
 const char kMediaRouterCastAllowAllIPsDescription[] =
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1037,6 +1037,9 @@ extern const char kLogJsConsoleMessagesDescription[];
 extern const char kUnthrottledNestedTimeoutName[];
 extern const char kUnthrottledNestedTimeoutDescription[];
 
+extern const char kMaxConnectionsPerHostName[];
+extern const char kMaxConnectionsPerHostDescription[];
+
 extern const char kMediaRouterCastAllowAllIPsName[];
 extern const char kMediaRouterCastAllowAllIPsDescription[];
 
--- a/chrome/browser/flags/android/java/src/org/chromium/chrome/browser/flags/ChromeFeatureList.java
+++ b/chrome/browser/flags/android/java/src/org/chromium/chrome/browser/flags/ChromeFeatureList.java
@@ -74,11 +74,7 @@ public abstract class ChromeFeatureList {
      *   the specified parameter does not exist.
      */
     public static String getFieldTrialParamByFeature(String featureName, String paramName) {
-        String testValue = FeatureList.getTestValueForFieldTrialParam(featureName, paramName);
-        if (testValue != null) return testValue;
-        if (FeatureList.hasTestFeatures()) return "";
-        assert FeatureList.isInitialized();
-        return ChromeFeatureListJni.get().getFieldTrialParamByFeature(featureName, paramName);
+        return "";
     }
 
     /**
@@ -95,12 +91,7 @@ public abstract class ChromeFeatureList {
      */
     public static int getFieldTrialParamByFeatureAsInt(
             String featureName, String paramName, int defaultValue) {
-        String testValue = FeatureList.getTestValueForFieldTrialParam(featureName, paramName);
-        if (testValue != null) return Integer.valueOf(testValue);
-        if (FeatureList.hasTestFeatures()) return defaultValue;
-        assert FeatureList.isInitialized();
-        return ChromeFeatureListJni.get().getFieldTrialParamByFeatureAsInt(
-                featureName, paramName, defaultValue);
+        return defaultValue;
     }
 
     /**
@@ -117,12 +108,7 @@ public abstract class ChromeFeatureList {
      */
     public static double getFieldTrialParamByFeatureAsDouble(
             String featureName, String paramName, double defaultValue) {
-        String testValue = FeatureList.getTestValueForFieldTrialParam(featureName, paramName);
-        if (testValue != null) return Double.valueOf(testValue);
-        if (FeatureList.hasTestFeatures()) return defaultValue;
-        assert FeatureList.isInitialized();
-        return ChromeFeatureListJni.get().getFieldTrialParamByFeatureAsDouble(
-                featureName, paramName, defaultValue);
+        return defaultValue;
     }
 
     /**
@@ -153,12 +139,7 @@ public abstract class ChromeFeatureList {
      */
     public static boolean getFieldTrialParamByFeatureAsBoolean(
             String featureName, String paramName, boolean defaultValue) {
-        String testValue = FeatureList.getTestValueForFieldTrialParam(featureName, paramName);
-        if (testValue != null) return Boolean.valueOf(testValue);
-        if (FeatureList.hasTestFeatures()) return defaultValue;
-        assert FeatureList.isInitialized();
-        return ChromeFeatureListJni.get().getFieldTrialParamByFeatureAsBoolean(
-                featureName, paramName, defaultValue);
+        return defaultValue;
     }
 
     /* Alphabetical: */
--- a/chrome/browser/media/router/discovery/dial/dial_registry.cc
+++ b/chrome/browser/media/router/discovery/dial/dial_registry.cc
@@ -154,10 +154,6 @@ void DialRegistry::StartPeriodicDiscovery() {
     return;
 
   dial_ = CreateDialService();
-  DoDiscovery();
-  repeating_timer_ = std::make_unique<base::RepeatingTimer>();
-  repeating_timer_->Start(FROM_HERE, refresh_interval_delta_, this,
-                          &DialRegistry::DoDiscovery);
   // Always send the current device list with the next discovery request.  This
   // may not be necessary, but is done to match previous behavior.
   ++registry_generation_;
@@ -174,8 +170,6 @@ void DialRegistry::StopPeriodicDiscovery() {
   if (!dial_)
     return;
 
-  repeating_timer_->Stop();
-  repeating_timer_.reset();
   ClearDialService();
 }
 
--- a/chrome/browser/media/router/discovery/mdns/dns_sd_device_lister.cc
+++ b/chrome/browser/media/router/discovery/mdns/dns_sd_device_lister.cc
@@ -40,37 +40,22 @@ DnsSdDeviceLister::DnsSdDeviceLister(
 DnsSdDeviceLister::~DnsSdDeviceLister() {}
 
 void DnsSdDeviceLister::Discover() {
-#if BUILDFLAG(ENABLE_SERVICE_DISCOVERY)
-  if (!device_lister_) {
-    device_lister_ = local_discovery::ServiceDiscoveryDeviceLister::Create(
-        this, service_discovery_client_, service_type_);
-    device_lister_->Start();
-  }
-  device_lister_->DiscoverNewDevices();
-#endif
 }
 
 void DnsSdDeviceLister::Reset() {
-  device_lister_.reset();
 }
 
 void DnsSdDeviceLister::OnDeviceChanged(
     const std::string& service_type,
     bool added,
     const ServiceDescription& service_description) {
-  DnsSdService service;
-  FillServiceInfo(service_description, &service);
-  delegate_->ServiceChanged(device_lister_->service_type(), added, service);
 }
 
 void DnsSdDeviceLister::OnDeviceRemoved(const std::string& service_type,
                                         const std::string& service_name) {
-  delegate_->ServiceRemoved(service_type, service_name);
 }
 
 void DnsSdDeviceLister::OnDeviceCacheFlushed(const std::string& service_type) {
-  delegate_->ServicesFlushed(device_lister_->service_type());
-  device_lister_->DiscoverNewDevices();
 }
 
 }  // namespace media_router
--- a/chrome/browser/media/webrtc/webrtc_log_uploader.cc
+++ b/chrome/browser/media/webrtc/webrtc_log_uploader.cc
@@ -126,28 +126,11 @@ void WebRtcLogUploader::LoggingStoppedDoUpload(
   DCHECK(meta_data.get());
   DCHECK(!upload_done_data.paths.directory.empty());
 
-  std::string compressed_log = CompressLog(log_buffer.get());
-
-  std::string local_log_id;
-
   if (base::PathExists(upload_done_data.paths.directory)) {
     webrtc_logging::DeleteOldWebRtcLogFiles(upload_done_data.paths.directory);
-
-    local_log_id = base::NumberToString(base::Time::Now().ToDoubleT());
-    base::FilePath log_file_path =
-        upload_done_data.paths.directory.AppendASCII(local_log_id)
-            .AddExtension(FILE_PATH_LITERAL(".gz"));
-    WriteCompressedLogToFile(compressed_log, log_file_path);
-
-    base::FilePath log_list_path =
-        webrtc_logging::TextLogList::GetWebRtcLogListFileForDirectory(
-            upload_done_data.paths.directory);
-    AddLocallyStoredLogInfoToUploadListFile(log_list_path, local_log_id);
   }
 
-  upload_done_data.local_log_id = local_log_id;
-  PrepareMultipartPostData(compressed_log, std::move(meta_data),
-                           std::move(upload_done_data));
+  NotifyUploadDoneAndLogStats(net::HTTP_OK, net::OK, "", std::move(upload_done_data));
 }
 
 void WebRtcLogUploader::PrepareMultipartPostData(
@@ -158,28 +141,7 @@ void WebRtcLogUploader::PrepareMultipartPostData(
   DCHECK(!compressed_log.empty());
   DCHECK(meta_data.get());
 
-  std::unique_ptr<std::string> post_data(new std::string());
-  SetupMultipart(post_data.get(), compressed_log,
-                 upload_done_data.paths.incoming_rtp_dump,
-                 upload_done_data.paths.outgoing_rtp_dump, *meta_data.get());
-
-  // If a test has set the test string pointer, write to it and skip uploading.
-  // Still fire the upload callback so that we can run an extension API test
-  // using the test framework for that without hanging.
-  // TODO(grunell): Remove this when the api test for this feature is fully
-  // implemented according to the test plan. http://crbug.com/257329.
-  if (post_data_) {
-    *post_data_ = *post_data;
-    NotifyUploadDoneAndLogStats(net::HTTP_OK, net::OK, "",
-                                std::move(upload_done_data));
-    return;
-  }
-
-  main_task_runner_->PostTask(
-      FROM_HERE,
-      base::BindOnce(&WebRtcLogUploader::UploadCompressedLog,
-                     base::Unretained(this), std::move(upload_done_data),
-                     std::move(post_data)));
+  NotifyUploadDoneAndLogStats(net::HTTP_OK, net::OK, "", std::move(upload_done_data));
 }
 
 void WebRtcLogUploader::UploadStoredLog(
@@ -245,49 +207,6 @@ void WebRtcLogUploader::LoggingStoppedDoStore(
   DCHECK(log_buffer.get());
   DCHECK(!log_paths.directory.empty());
 
-  webrtc_logging::DeleteOldWebRtcLogFiles(log_paths.directory);
-
-  base::FilePath log_list_path =
-      webrtc_logging::TextLogList::GetWebRtcLogListFileForDirectory(
-          log_paths.directory);
-
-  // Store the native log with a ".gz" extension.
-  std::string compressed_log = CompressLog(log_buffer.get());
-  base::FilePath native_log_path =
-      log_paths.directory.AppendASCII(log_id).AddExtension(
-          FILE_PATH_LITERAL(".gz"));
-  WriteCompressedLogToFile(compressed_log, native_log_path);
-  AddLocallyStoredLogInfoToUploadListFile(log_list_path, log_id);
-
-  // Move the rtp dump files to the log directory with a name of
-  // <log id>.rtp_[in|out].
-  if (!log_paths.incoming_rtp_dump.empty()) {
-    base::FilePath rtp_path =
-        log_paths.directory.AppendASCII(log_id).AddExtension(
-            FILE_PATH_LITERAL(".rtp_in"));
-    base::Move(log_paths.incoming_rtp_dump, rtp_path);
-  }
-
-  if (!log_paths.outgoing_rtp_dump.empty()) {
-    base::FilePath rtp_path =
-        log_paths.directory.AppendASCII(log_id).AddExtension(
-            FILE_PATH_LITERAL(".rtp_out"));
-    base::Move(log_paths.outgoing_rtp_dump, rtp_path);
-  }
-
-  if (meta_data.get() && !meta_data->empty()) {
-    base::Pickle pickle;
-    for (const auto& it : *meta_data.get()) {
-      pickle.WriteString(it.first);
-      pickle.WriteString(it.second);
-    }
-    base::FilePath meta_path =
-        log_paths.directory.AppendASCII(log_id).AddExtension(
-            FILE_PATH_LITERAL(".meta"));
-    base::WriteFile(meta_path, static_cast<const char*>(pickle.data()),
-                    pickle.size());
-  }
-
   main_task_runner_->PostTask(
       FROM_HERE, base::BindOnce(std::move(done_callback), true, ""));
 
--- a/chrome/browser/profiles/profile_shortcut_manager_win.cc
+++ b/chrome/browser/profiles/profile_shortcut_manager_win.cc
@@ -75,7 +75,7 @@ const int kMaxProfileShortcutFileNameLength = 64;
 // Incrementing this number will cause profile icons to be regenerated on
 // profile startup (it should be incremented whenever the product/avatar icons
 // change, etc).
-const int kCurrentProfileIconVersion = 10;
+const int kCurrentProfileIconVersion = 17;
 
 bool disabled_for_unit_tests = false;
 bool disable_unpinning_for_unit_tests = false;
--- a/chrome/browser/resources/settings/search_engines_page/search_engine_edit_dialog.html
+++ b/chrome/browser/resources/settings/search_engines_page/search_engine_edit_dialog.html
@@ -20,6 +20,13 @@
             value="{{queryUrl_}}" on-focus="validate_" on-input="validate_"
             disabled$="[[model.urlLocked]]">
         </cr-input>
+        <cr-input id="suggestionsUrl"
+            label="Suggestions URL with %s in place of query"
+            error-message="$i18n{notValid}"
+            value="{{suggestionsUrl_}}"
+            on-focus="validate_" on-input="validate_"
+            disabled$="[[model.urlLocked]]">
+        </cr-input>
       </div>
       <div slot="button-container">
         <cr-button class="cancel-button" on-click="cancel_" id="cancel">
--- a/chrome/browser/resources/settings/search_engines_page/search_engine_edit_dialog.ts
+++ b/chrome/browser/resources/settings/search_engines_page/search_engine_edit_dialog.ts
@@ -35,6 +35,7 @@ export interface SettingsSearchEngineEditDialogElement {
     dialog: CrDialogElement,
     keyword: CrInputElement,
     queryUrl: CrInputElement,
+    suggestionsUrl: CrInputElement,
     searchEngine: CrInputElement,
   };
 }
@@ -63,6 +64,7 @@ export class SettingsSearchEngineEditDialogElement extends
       searchEngine_: String,
       keyword_: String,
       queryUrl_: String,
+      suggestionsUrl_: String,
       dialogTitle_: String,
       actionButtonText_: String,
     };
@@ -72,6 +74,7 @@ export class SettingsSearchEngineEditDialogElement extends
   private searchEngine_: string;
   private keyword_: string;
   private queryUrl_: string;
+  private suggestionsUrl_: string;
   private dialogTitle_: string;
   private actionButtonText_: string;
   private browserProxy_: SearchEnginesBrowserProxy =
@@ -89,6 +92,7 @@ export class SettingsSearchEngineEditDialogElement extends
       this.searchEngine_ = this.model.name;
       this.keyword_ = this.model.keyword;
       this.queryUrl_ = this.model.url;
+      this.suggestionsUrl_ = this.model.suggestionsUrl;
     } else {
       this.dialogTitle_ =
           loadTimeData.getString('searchEnginesAddSearchEngine');
@@ -124,8 +128,12 @@ export class SettingsSearchEngineEditDialogElement extends
       }
     }
 
-    [this.$.searchEngine, this.$.keyword, this.$.queryUrl].forEach(
-        element => this.validateElement_(element));
+    [
+      this.$.searchEngine,
+      this.$.keyword,
+      this.$.queryUrl,
+      this.$.suggestionsUrl
+    ].forEach(element => this.validateElement_(element));
   }
 
   private cancel_() {
@@ -134,7 +142,8 @@ export class SettingsSearchEngineEditDialogElement extends
 
   private onActionButtonTap_() {
     this.browserProxy_.searchEngineEditCompleted(
-        this.searchEngine_, this.keyword_, this.queryUrl_);
+        this.searchEngine_, this.keyword_, this.queryUrl_,
+        this.suggestionsUrl_);
     this.$.dialog.close();
   }
 
@@ -165,8 +174,10 @@ export class SettingsSearchEngineEditDialogElement extends
       this.$.searchEngine,
       this.$.keyword,
       this.$.queryUrl,
+      this.$.suggestionsUrl,
     ].every(function(inputElement) {
-      return !inputElement.invalid && inputElement.value.length > 0;
+      return !inputElement.invalid && (inputElement.value.length > 0 ||
+          inputElement.id == 'suggestionsUrl');
     });
     this.$.actionButton.disabled = !allValid;
   }
--- a/chrome/browser/resources/settings/search_engines_page/search_engines_browser_proxy.ts
+++ b/chrome/browser/resources/settings/search_engines_page/search_engines_browser_proxy.ts
@@ -31,6 +31,7 @@ export interface SearchEngine {
   name: string;
   shouldConfirmDeletion: boolean;
   url: string;
+  suggestionsUrl: string;
   urlLocked: boolean;
 }
 
@@ -73,7 +74,7 @@ export interface SearchEnginesBrowserProxy {
   searchEngineEditCancelled(): void;
 
   searchEngineEditCompleted(
-      searchEngine: string, keyword: string, queryUrl: string): void;
+      searchEngine: string, keyword: string, queryUrl: string, suggestionsUrl: string): void;
 
   getSearchEnginesList(): Promise<SearchEnginesInfo>;
 
@@ -114,11 +115,12 @@ export class SearchEnginesBrowserProxyImpl implements
   }
 
   searchEngineEditCompleted(
-      searchEngine: string, keyword: string, queryUrl: string) {
+      searchEngine: string, keyword: string, queryUrl: string, suggestionsUrl: string) {
     chrome.send('searchEngineEditCompleted', [
       searchEngine,
       keyword,
       queryUrl,
+      suggestionsUrl,
     ]);
   }
 
--- a/chrome/browser/safe_browsing/chrome_safe_browsing_blocking_page_factory.cc
+++ b/chrome/browser/safe_browsing/chrome_safe_browsing_blocking_page_factory.cc
@@ -39,8 +39,7 @@ ChromeSafeBrowsingBlockingPageFactory::CreateSafeBrowsingPage(
       Profile::FromBrowserContext(web_contents->GetBrowserContext());
   // Create appropriate display options for this blocking page.
   PrefService* prefs = profile->GetPrefs();
-  bool is_extended_reporting_opt_in_allowed =
-      IsExtendedReportingOptInAllowed(*prefs);
+  bool is_extended_reporting_opt_in_allowed = false;
   bool is_proceed_anyway_disabled =
       prefs->GetBoolean(prefs::kSafeBrowsingProceedAnywayDisabled);
 
--- a/chrome/browser/safe_browsing/incident_reporting/incident_report_uploader_impl.cc
+++ b/chrome/browser/safe_browsing/incident_reporting/incident_report_uploader_impl.cc
@@ -27,7 +27,7 @@ namespace safe_browsing {
 namespace {
 
 const char kSbIncidentReportUrl[] =
-    "https://sb-ssl.google.com/safebrowsing/clientreport/incident";
+    "trk:268:https://sb-ssl.google.com/safebrowsing/clientreport/incident";
 
 constexpr net::NetworkTrafficAnnotationTag
     kSafeBrowsingIncidentTrafficAnnotation =
--- a/chrome/browser/safe_browsing/incident_reporting/incident_reporting_service.cc
+++ b/chrome/browser/safe_browsing/incident_reporting/incident_reporting_service.cc
@@ -304,11 +304,14 @@ IncidentReportingService::UploadContext::~UploadContext() {
 
 // static
 bool IncidentReportingService::IsEnabledForProfile(Profile* profile) {
+  return false;
+#if 0
   if (profile->IsOffTheRecord())
     return false;
   if (!IsSafeBrowsingEnabled(*profile->GetPrefs()))
     return false;
   return IsExtendedReportingEnabled(*profile->GetPrefs());
+#endif
 }
 
 IncidentReportingService::IncidentReportingService(
--- a/chrome/browser/safe_browsing/safe_browsing_service.cc
+++ b/chrome/browser/safe_browsing/safe_browsing_service.cc
@@ -299,7 +299,7 @@ SafeBrowsingUIManager* SafeBrowsingService::CreateUIManager() {
 }
 
 void SafeBrowsingService::RegisterAllDelayedAnalysis() {
-#if BUILDFLAG(FULL_SAFE_BROWSING)
+#if 0
   RegisterBinaryIntegrityAnalysis();
 #endif
 }
--- a/chrome/browser/sharing/features.cc
+++ b/chrome/browser/sharing/features.cc
@@ -10,6 +10,8 @@ BASE_FEATURE(kSharingMatchPulseInterval,
              "SharingMatchPulseInterval",
              base::FEATURE_DISABLED_BY_DEFAULT);
 
+BASE_FEATURE(kDisableQRGenerator, "DisableQRGenerator", base::FEATURE_DISABLED_BY_DEFAULT);
+
 const base::FeatureParam<int> kSharingPulseDeltaDesktopHours = {
     &kSharingMatchPulseInterval, "SharingPulseDeltaDesktopHours", 24};
 
--- a/chrome/browser/sharing/features.h
+++ b/chrome/browser/sharing/features.h
@@ -34,4 +34,5 @@ BASE_DECLARE_FEATURE(kSharingSendViaSync);
 // Feature flag for prefer sending sharing message using VAPID.
 BASE_DECLARE_FEATURE(kSharingPreferVapid);
 
+BASE_DECLARE_FEATURE(kDisableQRGenerator);
 #endif  // CHROME_BROWSER_SHARING_FEATURES_H_
--- a/chrome/browser/sharing_hub/sharing_hub_features.cc
+++ b/chrome/browser/sharing_hub/sharing_hub_features.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/sharing_hub/sharing_hub_features.h"
 
+#include "base/command_line.h"
 #include "build/build_config.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/share/share_features.h"
@@ -39,6 +40,7 @@ bool ScreenshotsDisabledByPolicy(content::BrowserContext* context) {
 }  // namespace
 
 bool SharingHubOmniboxEnabled(content::BrowserContext* context) {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("disable-sharing-hub")) return false;
 #if BUILDFLAG(IS_CHROMEOS)
   return false;
 #else
--- a/chrome/browser/ui/bookmarks/bookmark_tab_helper.cc
+++ b/chrome/browser/ui/bookmarks/bookmark_tab_helper.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/bookmarks/bookmark_tab_helper.h"
 
+#include "base/command_line.h"
 #include "base/observer_list.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -70,10 +71,12 @@ bool BookmarkTabHelper::ShouldShowBookmarkBar() const {
       !prefs->GetBoolean(bookmarks::prefs::kShowBookmarkBar))
     return false;
 
+  const std::string flag_value =
+    base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("bookmark-bar-ntp");
   // The bookmark bar is only shown on the NTP if the user
   // has added something to it.
   return IsNTP(web_contents()) && bookmark_model_ &&
-         bookmark_model_->HasBookmarks();
+         bookmark_model_->HasBookmarks() && (flag_value != "never");
 }
 
 void BookmarkTabHelper::AddObserver(BookmarkTabHelperObserver* observer) {
--- a/chrome/browser/ui/browser.cc
+++ b/chrome/browser/ui/browser.cc
@@ -139,6 +139,8 @@
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
 #include "chrome/browser/ui/tabs/tab_utils.h"
 #include "chrome/browser/ui/ui_features.h"
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "chrome/browser/ui/views/message_box_dialog.h"
 #include "chrome/browser/ui/web_applications/app_browser_controller.h"
 #include "chrome/browser/ui/web_applications/web_app_launch_utils.h"
 #include "chrome/browser/ui/webui/signin/login_ui_service.h"
@@ -475,6 +477,7 @@ Browser::Browser(const CreateParams& params)
       omit_from_session_restore_(params.omit_from_session_restore),
       should_trigger_session_restore_(params.should_trigger_session_restore),
       cancel_download_confirmation_state_(NOT_PROMPTED),
+      close_multitab_confirmation_state_(NOT_PROMPTED),
       override_bounds_(params.initial_bounds),
       initial_show_state_(params.initial_show_state),
       initial_workspace_(params.initial_workspace),
@@ -836,6 +839,7 @@ Browser::WarnBeforeClosingResult Browser::MaybeWarnBeforeClosing(
   // true or there are no pending downloads we need to prompt about) then
   // there's no need to warn.
   if (force_skip_warning_user_on_close_ || CanCloseWithInProgressDownloads())
+   if (CanCloseWithMultipleTabs())
     return WarnBeforeClosingResult::kOkToClose;
 
   DCHECK(!warn_before_closing_callback_)
@@ -870,6 +874,7 @@ bool Browser::TryToCloseWindow(
 
 void Browser::ResetTryToCloseWindow() {
   cancel_download_confirmation_state_ = NOT_PROMPTED;
+  close_multitab_confirmation_state_ = NOT_PROMPTED;
   unload_controller_.ResetTryToCloseWindow();
 }
 
@@ -2786,6 +2791,62 @@ bool Browser::CanCloseWithInProgressDownloads() {
   return false;
 }
 
+bool Browser::CanCloseWithMultipleTabs() {
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch("close-confirmation"))
+    return true;
+
+  // If we've prompted, we need to hear from the user before we
+  // can close.
+  if (close_multitab_confirmation_state_ != NOT_PROMPTED)
+    return close_multitab_confirmation_state_ != WAITING_FOR_RESPONSE;
+
+  // If we're not running a full browser process with a profile manager
+  // (testing), it's ok to close the browser.
+  if (!g_browser_process->profile_manager())
+    return true;
+
+  // Figure out how many windows are open total
+  int total_window_count = 0;
+  for (auto* browser : *BrowserList::GetInstance()) {
+    // Don't count this browser window or any other in the process of closing.
+    // Window closing may be delayed, and windows that are in the process of
+    // closing don't count against our totals.
+    if (browser == this || browser->IsAttemptingToCloseBrowser())
+      continue;
+    total_window_count++;
+  }
+
+  const auto flag_value = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("close-confirmation");
+  bool show_confirmation_last_window = flag_value == "last";
+
+  if (show_confirmation_last_window) {
+    if (total_window_count >= 1 || this->tab_strip_model()->count() <= 1)
+      return true;
+  } else {
+    if (total_window_count == 0)
+      return true;
+    if (this->tab_strip_model()->count() == 0)
+      tab_strip_model_delegate_->AddTabAt(GURL(), -1, true);
+  }
+
+  close_multitab_confirmation_state_ = WAITING_FOR_RESPONSE;
+
+  // The dialog eats mouse events which results in the close button
+  // getting stuck in the hover state. Reset the window controls to
+  // prevent this.
+  ((BrowserView*)window_)->frame()->non_client_view()->ResetWindowControls();
+  auto callback = base::BindOnce(&Browser::MultitabResponse,
+                                 weak_factory_.GetWeakPtr());
+  MessageBoxDialog::Show(window_->GetNativeWindow(),
+                         u"Do you want to close this window?", std::u16string(),
+                         chrome::MESSAGE_BOX_TYPE_QUESTION, u"Close", u"Cancel",
+                         std::u16string(), std::move(callback));
+
+  // Return false so the browser does not close.  We'll close if the user
+  // confirms in the dialog.
+  return false;
+}
+
 void Browser::InProgressDownloadResponse(bool cancel_downloads) {
   if (cancel_downloads) {
     cancel_download_confirmation_state_ = RESPONSE_RECEIVED;
@@ -2806,6 +2867,22 @@ void Browser::InProgressDownloadResponse(bool cancel_downloads) {
       .Run(WarnBeforeClosingResult::kDoNotClose);
 }
 
+void Browser::MultitabResponse(chrome::MessageBoxResult result) {
+  if (result == chrome::MESSAGE_BOX_RESULT_YES) {
+    close_multitab_confirmation_state_ = RESPONSE_RECEIVED;
+    std::move(warn_before_closing_callback_)
+        .Run(WarnBeforeClosingResult::kOkToClose);
+    return;
+  }
+
+  // Sets the confirmation state to NOT_PROMPTED so that if the user tries to
+  // close again we'll show the warning again.
+  close_multitab_confirmation_state_ = NOT_PROMPTED;
+
+  std::move(warn_before_closing_callback_)
+      .Run(WarnBeforeClosingResult::kDoNotClose);
+}
+
 void Browser::FinishWarnBeforeClosing(WarnBeforeClosingResult result) {
   switch (result) {
     case WarnBeforeClosingResult::kOkToClose:
--- a/chrome/browser/ui/browser.h
+++ b/chrome/browser/ui/browser.h
@@ -27,6 +27,7 @@
 #include "chrome/browser/ui/bookmarks/bookmark_tab_helper_observer.h"
 #include "chrome/browser/ui/browser_navigator_params.h"
 #include "chrome/browser/ui/chrome_web_modal_dialog_manager_delegate.h"
+#include "chrome/browser/ui/simple_message_box.h"
 #include "chrome/browser/ui/signin_view_controller.h"
 #include "chrome/browser/ui/tabs/tab_strip_model_observer.h"
 #include "chrome/browser/ui/unload_controller.h"
@@ -1047,12 +1048,17 @@ class Browser : public TabStripModelObserver,
   // Returns true if the window can close, false otherwise.
   bool CanCloseWithInProgressDownloads();
 
+  // Called when the window is closing to check if more than one tabs are open
+  bool CanCloseWithMultipleTabs();
+
   // Called when the user has decided whether to proceed or not with the browser
   // closure.  |cancel_downloads| is true if the downloads should be canceled
   // and the browser closed, false if the browser should stay open and the
   // downloads running.
   void InProgressDownloadResponse(bool cancel_downloads);
 
+  void MultitabResponse(chrome::MessageBoxResult result);
+
   // Called when all warnings have completed when attempting to close the
   // browser directly (e.g. via hotkey, close button, terminate signal, etc.)
   // Used as a WarnBeforeClosingCallback by ShouldCloseWindow().
@@ -1222,6 +1228,8 @@ class Browser : public TabStripModelObserver,
   // when the browser is closed with in-progress downloads.
   CancelDownloadConfirmationState cancel_download_confirmation_state_;
 
+  CancelDownloadConfirmationState close_multitab_confirmation_state_;
+
   /////////////////////////////////////////////////////////////////////////////
 
   // Override values for the bounds of the window and its maximized or minimized
--- a/chrome/browser/ui/browser_command_controller.cc
+++ b/chrome/browser/ui/browser_command_controller.cc
@@ -1205,7 +1205,8 @@ void BrowserCommandController::InitCommandState() {
   command_updater_.UpdateCommandEnabled(IDC_WINDOW_CLOSE_OTHER_TABS,
                                         normal_window);
 
-  const bool enable_tab_search_commands = browser_->is_type_normal();
+  const bool enable_tab_search_commands = browser_->is_type_normal() &&
+      !base::CommandLine::ForCurrentProcess()->HasSwitch("remove-tabsearch-button");
   command_updater_.UpdateCommandEnabled(IDC_TAB_SEARCH,
                                         enable_tab_search_commands);
   command_updater_.UpdateCommandEnabled(IDC_TAB_SEARCH_CLOSE,
--- a/chrome/browser/ui/browser_commands.cc
+++ b/chrome/browser/ui/browser_commands.cc
@@ -474,10 +474,6 @@ int GetContentRestrictions(const Browser* browser) {
     CoreTabHelper* core_tab_helper =
         CoreTabHelper::FromWebContents(current_tab);
     content_restrictions = core_tab_helper->content_restrictions();
-    NavigationEntry* last_committed_entry =
-        current_tab->GetController().GetLastCommittedEntry();
-    if (!content::IsSavableURL(last_committed_entry->GetURL()))
-      content_restrictions |= CONTENT_RESTRICTION_SAVE;
   }
   return content_restrictions;
 }
@@ -1379,8 +1375,7 @@ bool CanSavePage(const Browser* browser) {
       DownloadPrefs::DownloadRestriction::ALL_FILES) {
     return false;
   }
-  return !browser->is_type_devtools() &&
-         !(GetContentRestrictions(browser) & CONTENT_RESTRICTION_SAVE);
+  return true;
 }
 
 void Print(Browser* browser) {
--- a/chrome/browser/ui/qrcode_generator/qrcode_generator_bubble_controller.cc
+++ b/chrome/browser/ui/qrcode_generator/qrcode_generator_bubble_controller.cc
@@ -23,7 +23,7 @@ QRCodeGeneratorBubbleController::~QRCodeGeneratorBubbleController() {
 
 // static
 bool QRCodeGeneratorBubbleController::IsGeneratorAvailable(const GURL& url) {
-  if (!url.SchemeIsHTTPOrHTTPS())
+  if (!url.SchemeIsHTTPOrHTTPS() || base::FeatureList::IsEnabled(kDisableQRGenerator))
     return false;
 
   return true;
--- a/chrome/browser/ui/search_engines/edit_search_engine_controller.cc
+++ b/chrome/browser/ui/search_engines/edit_search_engine_controller.cc
@@ -67,6 +67,15 @@ bool EditSearchEngineController::IsURLValid(
       .is_valid();
 }
 
+bool EditSearchEngineController::IsSuggestionsURLValid(
+    const std::string& suggestions_url_input) const {
+  std::string suggestions_url = GetFixedUpURL(suggestions_url_input);
+  if (suggestions_url.empty())
+    return true;
+
+  return IsURLValid(suggestions_url);
+}
+
 bool EditSearchEngineController::IsKeywordValid(
     const std::u16string& keyword_input) const {
   std::u16string keyword_input_trimmed(
@@ -89,10 +98,12 @@ bool EditSearchEngineController::IsKeywordValid(
 void EditSearchEngineController::AcceptAddOrEdit(
     const std::u16string& title_input,
     const std::u16string& keyword_input,
-    const std::string& url_input) {
+    const std::string& url_input,
+    const std::string& suggestions_url_input) {
   DCHECK(!keyword_input.empty());
   std::string url_string = GetFixedUpURL(url_input);
   DCHECK(!url_string.empty());
+  std::string suggestions_url = GetFixedUpURL(suggestions_url_input);
 
   TemplateURLService* template_url_service =
       TemplateURLServiceFactory::GetForProfile(profile_);
@@ -120,7 +131,8 @@ void EditSearchEngineController::AcceptAddOrEdit(
   } else {
     // Adding or modifying an entry via the Delegate.
     edit_keyword_delegate_->OnEditedKeyword(template_url_, title_input,
-                                            keyword_input, url_string);
+                                            keyword_input, url_string,
+                                            suggestions_url);
   }
 }
 
--- a/chrome/browser/ui/search_engines/edit_search_engine_controller.h
+++ b/chrome/browser/ui/search_engines/edit_search_engine_controller.h
@@ -23,7 +23,8 @@ class EditSearchEngineControllerDelegate {
   virtual void OnEditedKeyword(TemplateURL* template_url,
                                const std::u16string& title,
                                const std::u16string& keyword,
-                               const std::string& url) = 0;
+                               const std::string& url,
+                               const std::string& suggestions_url) = 0;
 
  protected:
   virtual ~EditSearchEngineControllerDelegate() {}
@@ -54,6 +55,8 @@ class EditSearchEngineController {
   // character results in a valid url.
   bool IsURLValid(const std::string& url_input) const;
 
+  bool IsSuggestionsURLValid(const std::string& suggestions_url_input) const;
+
   // Returns true if the value of |keyword_input| represents a valid keyword.
   // The keyword is valid if it is non-empty and does not conflict with an
   // existing entry. NOTE: this is just the keyword, not the title and url.
@@ -62,7 +65,8 @@ class EditSearchEngineController {
   // Completes the add or edit of a search engine.
   void AcceptAddOrEdit(const std::u16string& title_input,
                        const std::u16string& keyword_input,
-                       const std::string& url_input);
+                       const std::string& url_input,
+                       const std::string& suggestions_url_input);
 
   // Deletes an unused TemplateURL, if its add was cancelled and it's not
   // already owned by the TemplateURLService.
--- a/chrome/browser/ui/search_engines/keyword_editor_controller.cc
+++ b/chrome/browser/ui/search_engines/keyword_editor_controller.cc
@@ -21,23 +21,27 @@ KeywordEditorController::KeywordEditorController(Profile* profile)
 KeywordEditorController::~KeywordEditorController() {
 }
 
-int KeywordEditorController::AddTemplateURL(const std::u16string& title,
-                                            const std::u16string& keyword,
-                                            const std::string& url) {
+int KeywordEditorController::AddTemplateURL(
+    const std::u16string& title,
+    const std::u16string& keyword,
+    const std::string& url,
+    const std::string& suggestions_url) {
   DCHECK(!url.empty());
 
   base::RecordAction(UserMetricsAction("KeywordEditor_AddKeyword"));
 
   const int new_index = table_model_->last_other_engine_index();
-  table_model_->Add(new_index, title, keyword, url);
+  table_model_->Add(new_index, title, keyword, url, suggestions_url);
 
   return new_index;
 }
 
-void KeywordEditorController::ModifyTemplateURL(TemplateURL* template_url,
-                                                const std::u16string& title,
-                                                const std::u16string& keyword,
-                                                const std::string& url) {
+void KeywordEditorController::ModifyTemplateURL(
+    TemplateURL* template_url,
+    const std::u16string& title,
+    const std::u16string& keyword,
+    const std::string& url,
+    const std::string& suggestions_url) {
   DCHECK(!url.empty());
   const absl::optional<size_t> index =
       table_model_->IndexOfTemplateURL(template_url);
@@ -49,11 +53,13 @@ void KeywordEditorController::ModifyTemplateURL(TemplateURL* template_url,
 
   // Don't do anything if the entry didn't change.
   if ((template_url->short_name() == title) &&
-      (template_url->keyword() == keyword) && (template_url->url() == url))
-    return;
-
-  table_model_->ModifyTemplateURL(index.value(), title, keyword, url);
+      (template_url->keyword() == keyword) &&
+      (template_url->url() == url) &&
+      (template_url->suggestions_url() == suggestions_url))
+  return;
 
+  table_model_->ModifyTemplateURL(index.value(), title, keyword, url, suggestions_url);
+  
   base::RecordAction(UserMetricsAction("KeywordEditor_ModifiedKeyword"));
 }
 
--- a/chrome/browser/ui/search_engines/keyword_editor_controller.h
+++ b/chrome/browser/ui/search_engines/keyword_editor_controller.h
@@ -29,14 +29,16 @@ class KeywordEditorController {
   // model.  Returns the index of the added URL.
   int AddTemplateURL(const std::u16string& title,
                      const std::u16string& keyword,
-                     const std::string& url);
+                     const std::string& url,
+                     const std::string& suggestions_url);
 
   // Invoked when the user modifies a TemplateURL. Updates the
   // TemplateURLService and table model appropriately.
   void ModifyTemplateURL(TemplateURL* template_url,
                          const std::u16string& title,
                          const std::u16string& keyword,
-                         const std::string& url);
+                         const std::string& url,
+                         const std::string& suggestions_url);
 
   // Return true if the given |url| can be edited.
   bool CanEdit(const TemplateURL* url) const;
--- a/chrome/browser/ui/search_engines/template_url_table_model.cc
+++ b/chrome/browser/ui/search_engines/template_url_table_model.cc
@@ -112,21 +112,25 @@ void TemplateURLTableModel::Remove(size_t index) {
 void TemplateURLTableModel::Add(size_t index,
                                 const std::u16string& short_name,
                                 const std::u16string& keyword,
-                                const std::string& url) {
+                                const std::string& url,
+                                const std::string& suggestions_url) {
   DCHECK(index <= RowCount());
   DCHECK(!url.empty());
   TemplateURLData data;
   data.SetShortName(short_name);
   data.SetKeyword(keyword);
   data.SetURL(url);
+  data.suggestions_url = suggestions_url;
   data.is_active = TemplateURLData::ActiveStatus::kTrue;
   template_url_service_->Add(std::make_unique<TemplateURL>(data));
 }
 
-void TemplateURLTableModel::ModifyTemplateURL(size_t index,
-                                              const std::u16string& title,
-                                              const std::u16string& keyword,
-                                              const std::string& url) {
+void TemplateURLTableModel::ModifyTemplateURL(
+    size_t index,
+    const std::u16string& title,
+    const std::u16string& keyword,
+    const std::string& url,
+    const std::string& suggestions_url) {
   DCHECK(index <= RowCount());
   DCHECK(!url.empty());
   TemplateURL* template_url = GetTemplateURL(index);
@@ -135,7 +139,8 @@ void TemplateURLTableModel::ModifyTemplateURL(size_t index,
   DCHECK(template_url_service_->GetDefaultSearchProvider() != template_url ||
          template_url->SupportsReplacement(
              template_url_service_->search_terms_data()));
-  template_url_service_->ResetTemplateURL(template_url, title, keyword, url);
+  template_url_service_->ResetTemplateURL(template_url, title, keyword, url,
+                                          suggestions_url);
 }
 
 TemplateURL* TemplateURLTableModel::GetTemplateURL(size_t index) {
--- a/chrome/browser/ui/search_engines/template_url_table_model.h
+++ b/chrome/browser/ui/search_engines/template_url_table_model.h
@@ -54,13 +54,15 @@ class TemplateURLTableModel : public ui::TableModel,
   void Add(size_t index,
            const std::u16string& short_name,
            const std::u16string& keyword,
-           const std::string& url);
+           const std::string& url,
+           const std::string& suggestions_url);
 
   // Update the entry at the specified index.
   void ModifyTemplateURL(size_t index,
                          const std::u16string& title,
                          const std::u16string& keyword,
-                         const std::string& url);
+                         const std::string& url,
+                         const std::string& suggestions_url);
 
   // Reloads the icon at the specified index.
   void ReloadIcon(size_t index);
--- a/chrome/browser/ui/startup/bad_flags_prompt.cc
+++ b/chrome/browser/ui/startup/bad_flags_prompt.cc
@@ -63,7 +63,6 @@ static const char* kBadFlags[] = {
     // These flags disable sandbox-related security.
     sandbox::policy::switches::kDisableGpuSandbox,
     sandbox::policy::switches::kDisableSeccompFilterSandbox,
-    sandbox::policy::switches::kDisableSetuidSandbox,
     sandbox::policy::switches::kNoSandbox,
 #if BUILDFLAG(IS_WIN)
     sandbox::policy::switches::kAllowThirdPartyModules,
--- a/chrome/browser/ui/startup/google_api_keys_infobar_delegate.cc
+++ b/chrome/browser/ui/startup/google_api_keys_infobar_delegate.cc
@@ -17,9 +17,6 @@
 // static
 void GoogleApiKeysInfoBarDelegate::Create(
     infobars::ContentInfoBarManager* infobar_manager) {
-  infobar_manager->AddInfoBar(
-      CreateConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate>(
-          new GoogleApiKeysInfoBarDelegate())));
 }
 
 GoogleApiKeysInfoBarDelegate::GoogleApiKeysInfoBarDelegate()
--- a/chrome/browser/ui/startup/infobar_utils.cc
+++ b/chrome/browser/ui/startup/infobar_utils.cc
@@ -99,7 +99,8 @@ void AddInfoBarsIfNecessary(Browser* browser,
     return;
 
   // Web apps should not display the session restore bubble (crbug.com/1264121)
-  if (!is_web_app && HasPendingUncleanExit(browser->profile()))
+  if (!is_web_app && HasPendingUncleanExit(browser->profile()) &&
+      !startup_command_line.HasSwitch("hide-crashed-bubble"))
     SessionCrashedBubble::ShowIfNotOffTheRecordProfile(
         browser, /*skip_tab_checking=*/false);
 
@@ -125,9 +126,6 @@ void AddInfoBarsIfNecessary(Browser* browser,
     if (show_bad_flags_security_warnings)
       chrome::ShowBadFlagsPrompt(web_contents);
 
-    if (!google_apis::HasAPIKeyConfigured())
-      GoogleApiKeysInfoBarDelegate::Create(infobar_manager);
-
     if (ObsoleteSystem::IsObsoleteNowOrSoon()) {
       PrefService* local_state = g_browser_process->local_state();
       if (!local_state ||
--- a/chrome/browser/ui/tabs/tab_strip_model.cc
+++ b/chrome/browser/ui/tabs/tab_strip_model.cc
@@ -10,6 +10,7 @@
 #include <utility>
 
 #include "base/auto_reset.h"
+#include "base/command_line.h"
 #include "base/containers/adapters.h"
 #include "base/containers/contains.h"
 #include "base/containers/flat_map.h"
@@ -1829,6 +1830,10 @@ bool TabStripModel::CloseTabs(base::span<content::WebContents* const> items,
   if (items.empty())
     return true;
 
+  const std::string flag_value = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("close-window-with-last-tab");
+  if (flag_value == "never" && !closing_all_ && items.size() == count())
+    delegate()->AddTabAt(GURL(), -1, true);
+
   const bool closing_all = static_cast<int>(items.size()) == count();
   base::WeakPtr<TabStripModel> ref = weak_factory_.GetWeakPtr();
   if (closing_all) {
--- a/chrome/browser/ui/views/extensions/extensions_toolbar_container.cc
+++ b/chrome/browser/ui/views/extensions/extensions_toolbar_container.cc
@@ -10,6 +10,7 @@
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
+#include "base/command_line.h"
 #include "base/no_destructor.h"
 #include "base/ranges/algorithm.h"
 #include "build/build_config.h"
@@ -32,6 +33,7 @@
 #include "chrome/browser/ui/views/frame/toolbar_button_provider.h"
 #include "chrome/browser/ui/views/toolbar/toolbar_action_hover_card_controller.h"
 #include "chrome/browser/ui/views/toolbar/toolbar_actions_bar_bubble_views.h"
+#include "chrome/browser/ui/views/toolbar/toolbar_view.h"
 #include "extensions/common/extension_features.h"
 #include "ui/base/dragdrop/drag_drop_types.h"
 #include "ui/base/dragdrop/mojom/drag_drop_types.mojom-shared.h"
@@ -347,6 +349,16 @@ void ExtensionsToolbarContainer::AnchorAndShowWidgetImmediately(
   widget->widget_delegate()->AsBubbleDialogDelegate()->SetAnchorView(
       anchor_view && anchor_view->GetVisible() ? anchor_view
                                                : GetExtensionsButton());
+
+  // Fix the position of widgets. Without this fix, extension-installed-bubble
+  // and extension-uninstall-dialog may be out of the window border on Linux.
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("hide-extensions-menu"))
+  {
+    views::View* anchor_view = BrowserView::GetBrowserViewForBrowser(browser_)
+      ->toolbar_button_provider()->GetAppMenuButton();
+    widget->widget_delegate()->AsBubbleDialogDelegate()
+      ->SetAnchorView(anchor_view);
+  }
   widget->Show();
 }
 
@@ -849,6 +861,9 @@ void ExtensionsToolbarContainer::UpdateContainerVisibility() {
 }
 
 bool ExtensionsToolbarContainer::ShouldContainerBeVisible() const {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("hide-extensions-menu"))
+    return false;
+
   // The container (and extensions-menu button) should not be visible if we have
   // no extensions.
   if (!HasAnyExtensions())
--- a/chrome/browser/ui/views/frame/browser_frame.cc
+++ b/chrome/browser/ui/views/frame/browser_frame.cc
@@ -441,5 +441,8 @@ bool BrowserFrame::RegenerateFrameOnThemeChange(
 }
 
 bool BrowserFrame::ShouldUseDarkTheme() const {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("enable-incognito-themes") &&
+      !browser_view_->GetIsPictureInPictureType())
+    return false;
   return browser_view_->browser()->profile()->IsIncognitoProfile();
 }
--- a/chrome/browser/ui/views/frame/browser_root_view.cc
+++ b/chrome/browser/ui/views/frame/browser_root_view.cc
@@ -11,6 +11,7 @@
 
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
+#include "base/command_line.h"
 #include "base/metrics/user_metrics.h"
 #include "base/task/thread_pool.h"
 #include "chrome/browser/autocomplete/autocomplete_classifier_factory.h"
@@ -112,6 +113,18 @@ DragOperation GetDropEffect(const ui::DropTargetEvent& event, const GURL& url) {
   return DragOperation::kMove;
 }
 
+bool ShouldScrollChangesTab() {
+  const std::string flag_value =
+    base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("scroll-tabs");
+
+  if (flag_value == "always")
+    return true;
+  else if (flag_value == "never")
+    return false;
+
+  return browser_defaults::kScrollEventChangesTab;
+}
+
 }  // namespace
 
 BrowserRootView::DropInfo::DropInfo() = default;
@@ -123,7 +136,9 @@ BrowserRootView::DropInfo::~DropInfo() {
 
 BrowserRootView::BrowserRootView(BrowserView* browser_view,
                                  views::Widget* widget)
-    : views::internal::RootView(widget), browser_view_(browser_view) {}
+    : views::internal::RootView(widget), browser_view_(browser_view) {
+  scroll_event_changes_tab_ = ShouldScrollChangesTab();
+}
 
 BrowserRootView::~BrowserRootView() {
   // It's possible to destroy the browser while a drop is active.  In this case,
@@ -250,7 +265,7 @@ bool BrowserRootView::OnMouseWheel(const ui::MouseWheelEvent& event) {
 
   // Scroll-event-changes-tab is incompatible with scrolling tabstrip, so
   // disable it if the latter feature is enabled.
-  if (browser_defaults::kScrollEventChangesTab &&
+  if (scroll_event_changes_tab_ &&
       !base::FeatureList::IsEnabled(features::kScrollableTabStrip)) {
     // Switch to the left/right tab if the wheel-scroll happens over the
     // tabstrip, or the empty space beside the tabstrip.
--- a/chrome/browser/ui/views/frame/browser_root_view.h
+++ b/chrome/browser/ui/views/frame/browser_root_view.h
@@ -143,6 +143,8 @@ class BrowserRootView : public views::internal::RootView {
   int scroll_remainder_x_ = 0;
   int scroll_remainder_y_ = 0;
 
+  bool scroll_event_changes_tab_ = false;
+
   std::unique_ptr<DropInfo> drop_info_;
 
   base::WeakPtrFactory<BrowserRootView> weak_ptr_factory_{this};
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -1789,6 +1789,10 @@ void BrowserView::UpdateExclusiveAccessExitBubbleContent(
     ExclusiveAccessBubbleHideCallback bubble_first_hide_callback,
     bool notify_download,
     bool force_update) {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          "hide-fullscreen-exit-ui"))
+    return;
+
   DCHECK(!notify_download || exclusive_access_bubble_);
   // Trusted pinned mode does not allow to escape. So do not show the bubble.
   bool is_trusted_pinned =
--- a/chrome/browser/ui/views/frame/tab_strip_region_view.cc
+++ b/chrome/browser/ui/views/frame/tab_strip_region_view.cc
@@ -5,6 +5,7 @@
 #include "chrome/browser/ui/views/frame/tab_strip_region_view.h"
 
 #include "base/functional/bind.h"
+#include "base/command_line.h"
 #include "base/strings/utf_string_conversions.h"
 #include "build/build_config.h"
 #include "chrome/browser/themes/theme_properties.h"
@@ -48,6 +49,7 @@ class FrameGrabHandle : public views::View {
     // Reserve some space for the frame to be grabbed by, even if the tabstrip
     // is full.
     // TODO(tbergquist): Define this relative to the NTB insets again.
+    if (base::CommandLine::ForCurrentProcess()->HasSwitch("remove-grab-handle")) return gfx::Size(0, 0);
     return gfx::Size(42, 0);
   }
 };
@@ -143,7 +145,8 @@ TabStripRegionView::TabStripRegionView(std::unique_ptr<TabStrip> tab_strip) {
     return;
   }
 
-  if (browser->is_type_normal()) {
+  if (browser->is_type_normal() &&
+      !base::CommandLine::ForCurrentProcess()->HasSwitch("remove-tabsearch-button")) {
     auto tab_search_button = std::make_unique<TabSearchButton>(tab_strip_);
     tab_search_button->SetTooltipText(
         l10n_util::GetStringUTF16(IDS_TOOLTIP_TAB_SEARCH));
--- a/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc
+++ b/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc
@@ -69,6 +69,10 @@ bool IsExitUiEnabled() {
   // menu and controls reveal when the cursor is moved to the top.
   return false;
 #else
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          "hide-fullscreen-exit-ui"))
+    return false;
+
   // Kiosk mode is a fullscreen experience, which makes the exit UI
   // inappropriate.
   return !chrome::IsRunningInAppMode();
--- a/chrome/browser/ui/views/location_bar/location_bar_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.cc
@@ -307,7 +307,8 @@ void LocationBarView::Init() {
 
     params.types_enabled.push_back(PageActionIconType::kSendTabToSelf);
     params.types_enabled.push_back(PageActionIconType::kClickToCall);
-    params.types_enabled.push_back(PageActionIconType::kQRCodeGenerator);
+    if (!base::FeatureList::IsEnabled(kDisableQRGenerator))
+      params.types_enabled.push_back(PageActionIconType::kQRCodeGenerator);
     if (base::FeatureList::IsEnabled(kWebOTPCrossDevice))
       params.types_enabled.push_back(PageActionIconType::kSmsRemoteFetcher);
     params.types_enabled.push_back(PageActionIconType::kManagePasswords);
--- a/chrome/browser/ui/views/tabs/new_tab_button.cc
+++ b/chrome/browser/ui/views/tabs/new_tab_button.cc
@@ -61,10 +61,8 @@ NewTabButton::NewTabButton(TabStrip* tab_strip, PressedCallback callback)
   SetAnimateOnStateChange(true);
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
   SetTriggerableEventFlags(GetTriggerableEventFlags() |
                            ui::EF_MIDDLE_MOUSE_BUTTON);
-#endif
 
   ink_drop_container_ =
       AddChildView(std::make_unique<views::InkDropContainerView>());
--- a/chrome/browser/ui/views/tabs/tab.cc
+++ b/chrome/browser/ui/views/tabs/tab.cc
@@ -13,6 +13,7 @@
 
 #include "base/debug/alias.h"
 #include "base/functional/bind.h"
+#include "base/command_line.h"
 #include "base/i18n/rtl.h"
 #include "base/memory/raw_ptr.h"
 #include "base/metrics/user_metrics.h"
@@ -642,6 +643,8 @@ void Tab::OnGestureEvent(ui::GestureEvent* event) {
 }
 
 std::u16string Tab::GetTooltipText(const gfx::Point& p) const {
+  if (base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("tab-hover-cards") == "tooltip")
+    return GetTooltipText(data_.title, GetAlertStateToShow(data_.alert_state));
   // Tab hover cards replace tooltips for tabs.
   return std::u16string();
 }
@@ -989,7 +992,11 @@ void Tab::UpdateIconVisibility() {
   if (IsActive()) {
     // Close button is shown on active tabs regardless of the size.
     showing_close_button_ = true;
-    available_width -= close_button_width;
+    if (base::CommandLine::ForCurrentProcess()->HasSwitch("hide-tab-close-buttons")) {
+      showing_close_button_ = false;
+    } else {
+      available_width -= close_button_width;
+    }
 
     showing_alert_indicator_ =
         has_alert_icon && alert_icon_width <= available_width;
@@ -1010,6 +1017,8 @@ void Tab::UpdateIconVisibility() {
       available_width -= favicon_width;
 
     showing_close_button_ = large_enough_for_close_button;
+    if (base::CommandLine::ForCurrentProcess()->HasSwitch("hide-tab-close-buttons"))
+      showing_close_button_ = false;
     if (showing_close_button_)
       available_width -= close_button_width;
 
--- a/chrome/browser/ui/views/tabs/tab_strip.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip.cc
@@ -22,6 +22,7 @@
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
+#include "base/command_line.h"
 #include "base/i18n/rtl.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/weak_ptr.h"
@@ -1643,6 +1644,8 @@ void TabStrip::OnMouseEventInTab(views::View* source,
 }
 
 void TabStrip::UpdateHoverCard(Tab* tab, HoverCardUpdateType update_type) {
+  if (base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("tab-hover-cards") == "tooltip" ||
+      base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("tab-hover-cards") == "none") return;
   tab_container_->UpdateHoverCard(tab, update_type);
 }
 
@@ -1890,8 +1893,6 @@ void TabStrip::NewTabButtonPressed(const ui::Event& event) {
 
     const ui::MouseEvent& mouse = static_cast<const ui::MouseEvent&>(event);
     if (mouse.IsOnlyMiddleMouseButton()) {
-      if (ui::Clipboard::IsSupportedClipboardBuffer(
-              ui::ClipboardBuffer::kSelection)) {
         ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
         CHECK(clipboard);
         std::u16string clipboard_text;
@@ -1899,7 +1900,6 @@ void TabStrip::NewTabButtonPressed(const ui::Event& event) {
                             /* data_dst = */ nullptr, &clipboard_text);
         if (!clipboard_text.empty())
           controller_->CreateNewTabWithLocation(clipboard_text);
-      }
       return;
     }
   }
--- a/chrome/browser/ui/views/toolbar/reload_button.cc
+++ b/chrome/browser/ui/views/toolbar/reload_button.cc
@@ -84,7 +84,7 @@ bool ReloadButton::GetMenuEnabled() const {
 }
 
 void ReloadButton::SetMenuEnabled(bool enable) {
-  menu_enabled_ = enable;
+  menu_enabled_ = true;
 }
 
 void ReloadButton::OnMouseExited(const ui::MouseEvent& event) {
--- a/chrome/browser/ui/views/toolbar/toolbar_view.cc
+++ b/chrome/browser/ui/views/toolbar/toolbar_view.cc
@@ -348,18 +348,31 @@ void ToolbarView::Init() {
     side_panel_button_ = AddChildView(std::move(side_panel_button));
 
   avatar_ = AddChildView(std::make_unique<AvatarToolbarButton>(browser_view_));
+
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  const std::string flag_value =
+      command_line.GetSwitchValueASCII("show-avatar-button");
+
+  bool in_incognito_or_guest_mode = browser_->profile()->IsIncognitoProfile() ||
+                                    browser_->profile()->IsGuestSession();
+
   bool show_avatar_toolbar_button = true;
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   // ChromeOS only badges Incognito, Guest, and captive portal signin icons in
   // the browser window.
-  show_avatar_toolbar_button =
-      browser_->profile()->IsIncognitoProfile() ||
-      browser_->profile()->IsGuestSession() ||
-      (browser_->profile()->IsOffTheRecord() &&
-       browser_->profile()->GetOTRProfileID().IsCaptivePortal());
+  show_avatar_toolbar_button = in_incognito_or_guest_mode;
 #elif BUILDFLAG(IS_CHROMEOS_LACROS)
   show_avatar_toolbar_button = !profiles::IsPublicSession();
 #endif
+
+  if (flag_value == "always")
+    show_avatar_toolbar_button = true;
+  else if (flag_value == "incognito-and-guest")
+    show_avatar_toolbar_button = in_incognito_or_guest_mode;
+  else if (flag_value == "never")
+    show_avatar_toolbar_button = false;
+
   avatar_->SetVisible(show_avatar_toolbar_button);
 
   auto app_menu_button = std::make_unique<BrowserAppMenuButton>(this);
--- a/chrome/browser/ui/webui/ntp/ntp_resource_cache.cc
+++ b/chrome/browser/ui/webui/ntp/ntp_resource_cache.cc
@@ -432,7 +432,9 @@ void NTPResourceCache::CreateNewTabIncognitoCSS(
       profile_->GetPrefs()->GetString(prefs::kCurrentThemeID);
 
   // Colors.
-  const ui::ColorProvider& cp = web_contents->GetColorProvider();
+  auto key = native_theme->GetColorProviderKey(nullptr);
+  key.color_mode = ui::ColorProviderManager::ColorMode::kDark;
+  const ui::ColorProvider& cp = *ui::ColorProviderManager::Get().GetColorProviderFor(key);
   substitutions["colorBackground"] = color_utils::SkColorToRgbaString(
       GetThemeColor(native_theme, cp, kColorNewTabPageBackground));
   substitutions["backgroundPosition"] = GetNewTabBackgroundPositionCSS(tp);
--- a/chrome/browser/ui/webui/settings/search_engines_handler.cc
+++ b/chrome/browser/ui/webui/settings/search_engines_handler.cc
@@ -37,6 +37,7 @@ namespace {
 const char kSearchEngineField[] = "searchEngine";
 const char kKeywordField[] = "keyword";
 const char kQueryUrlField[] = "queryUrl";
+const char kSuggestionsUrlField[] = "suggestionsUrl";
 
 // Dummy number used for indicating that a new search engine is added.
 const int kNewSearchEngine@@ -206,6 +207,8 @@ base::Value::Dict SearchEnginesHandler::CreateDictionaryForEngine(
   Profile* profile = Profile::FromWebUI(web_ui());
   dict.Set("url",
            template_url->url_ref().DisplayURL(UIThreadSearchTermsData()));
+  dict.Set("suggestionsUrl", template_url->suggestions_url_ref().DisplayURL(
+           UIThreadSearchTermsData()));
   dict.Set("urlLocked", ((template_url->prepopulate_id() > 0) ||
                          (template_url->starter_pack_id() > 0)));
   GURL icon_url = template_url->favicon_url();
@@ -313,12 +316,14 @@ void SearchEnginesHandler::HandleSearchEngineEditStarted(
 void SearchEnginesHandler::OnEditedKeyword(TemplateURL* template_url,
                                            const std::u16string& title,
                                            const std::u16string& keyword,
-                                           const std::string& url) {
+                                           const std::string& url,
+                                           const std::string& suggestions_url) {
   DCHECK(!url.empty());
   if (template_url)
-    list_controller_.ModifyTemplateURL(template_url, title, keyword, url);
+    list_controller_.ModifyTemplateURL(template_url, title, keyword, url,
+                                       suggestions_url);
   else
-    list_controller_.AddTemplateURL(title, keyword, url);
+    list_controller_.AddTemplateURL(title, keyword, url, suggestions_url);
 
   edit_controller_.reset();
 }
@@ -346,6 +351,8 @@ bool SearchEnginesHandler::CheckFieldValidity(const std::string& field_name,
     is_valid = edit_controller_->IsKeywordValid(base::UTF8ToUTF16(field_value));
   else if (field_name.compare(kQueryUrlField) == 0)
     is_valid = edit_controller_->IsURLValid(field_value);
+  else if (field_name.compare(kSuggestionsUrlField) == 0)
+    is_valid = edit_controller_->IsSuggestionsURLValid(field_value);
   else
     NOTREACHED();
 
@@ -365,18 +372,21 @@ void SearchEnginesHandler::HandleSearchEngineEditCompleted(
   if (!edit_controller_.get())
     return;
 
-  CHECK_EQ(3U, args.size());
+  CHECK_EQ(4U, args.size());
   const std::string& search_engine = args[0].GetString();
   const std::string& keyword = args[1].GetString();
   const std::string& query_url = args[2].GetString();
+  const std::string& suggestions_url = args[3].GetString();
 
   // Recheck validity. It's possible to get here with invalid input if e.g. the
   // user calls the right JS functions directly from the web inspector.
   if (CheckFieldValidity(kSearchEngineField, search_engine) &&
       CheckFieldValidity(kKeywordField, keyword) &&
-      CheckFieldValidity(kQueryUrlField, query_url)) {
+      CheckFieldValidity(kQueryUrlField, query_url) &&
+      CheckFieldValidity(kSuggestionsUrlField, suggestions_url)) {
     edit_controller_->AcceptAddOrEdit(base::UTF8ToUTF16(search_engine),
-                                      base::UTF8ToUTF16(keyword), query_url);
+                                      base::UTF8ToUTF16(keyword),
+                                      query_url, suggestions_url);
   }
 }
 
--- a/chrome/browser/ui/webui/settings/search_engines_handler.h
+++ b/chrome/browser/ui/webui/settings/search_engines_handler.h
@@ -45,7 +45,8 @@ class SearchEnginesHandler : public SettingsPageUIHandler,
   void OnEditedKeyword(TemplateURL* template_url,
                        const std::u16string& title,
                        const std::u16string& keyword,
-                       const std::string& url) override;
+                       const std::string& url,
+                       const std::string& suggestions_url) override;
 
   // SettingsPageUIHandler implementation.
   void RegisterMessages() override;
@@ -77,8 +78,8 @@ class SearchEnginesHandler : public SettingsPageUIHandler,
   // to WebUI. Called from WebUI.
   void HandleValidateSearchEngineInput(const base::Value::List& args);
 
-  // Checks whether the given user input field (searchEngine, keyword, queryUrl)
-  // is populated with a valid value.
+  // Checks whether the given user input field (searchEngine, keyword, queryUrl,
+  // suggestionsUrl) is populated with a valid value.
   bool CheckFieldValidity(const std::string& field_name,
                           const std::string& field_value);
 
--- a/chrome/browser/web_applications/chrome_pwa_launcher/chrome_pwa_launcher_exe.rc
+++ b/chrome/browser/web_applications/chrome_pwa_launcher/chrome_pwa_launcher_exe.rc
@@ -1,7 +1,3 @@
 #include "build/branding_buildflags.h"
 
-#if BUILDFLAG(GOOGLE_CHROME_BRANDING)
-1 ICON "..\\..\\..\\app\\theme\\google_chrome\\win\\chrome_pwa_launcher.ico"
-#else
 1 ICON "chrome_pwa_launcher.ico"
-#endif
--- a/chrome/common/BUILD.gn
+++ b/chrome/common/BUILD.gn
@@ -419,7 +419,6 @@ static_library("common_lib") {
     ]
     deps += [
       "//chrome/chrome_elf:chrome_elf_main_include",
-      "//chrome/common/win:eventlog_messages",
       "//components/crash/core/app:crash_export_thunk_include",
     ]
 
--- a/chrome/common/logging_chrome.cc
+++ b/chrome/common/logging_chrome.cc
@@ -64,7 +64,6 @@
 #include <initguid.h>
 #include "base/logging_win.h"
 #include "base/syslog_logging.h"
-#include "chrome/common/win/eventlog_messages.h"
 #include "chrome/install_static/install_details.h"
 #endif
 
@@ -455,11 +454,6 @@ void InitChromeLogging(const base::CommandLine& command_line,
 #if BUILDFLAG(IS_WIN)
   // Enable trace control and transport through event tracing for Windows.
   LogEventProvider::Initialize(kChromeTraceProviderName);
-
-  // Enable logging to the Windows Event Log.
-  SetEventSource(base::WideToASCII(
-                     install_static::InstallDetails::Get().install_full_name()),
-                 BROWSER_CATEGORY, MSG_LOG_MESSAGE);
 #endif
 
   base::StatisticsRecorder::InitLogOnShutdown();
--- a/chrome/install_static/chromium_install_modes.cc
+++ b/chrome/install_static/chromium_install_modes.cc
@@ -14,13 +14,13 @@
 
 namespace install_static {
 
-const wchar_t kCompanyPathName[] = L"";
+const wchar_t kCompanyPathName[] = L"Xempre";
 
-const wchar_t kProductPathName[] = L"Chromium";
+const wchar_t kProductPathName[] = L"Croma";
 
 const size_t kProductPathNameLength = _countof(kProductPathName) - 1;
 
-const char kSafeBrowsingName[] = "chromium";
+const char kSafeBrowsingName[] = "croma";
 
 const InstallConstants kInstallModes[] = {
     // The primary (and only) install mode for Chromium.
@@ -33,12 +33,12 @@ const InstallConstants kInstallModes[] = {
             L"",  // Empty install_suffix for the primary install mode.
         .logo_suffix = L"",  // No logo suffix for the primary install mode.
         .app_guid =
-            L"",  // Empty app_guid since no integration with Google Update.
-        .base_app_name = L"Chromium",      // A distinct base_app_name.
-        .base_app_id = L"Chromium",        // A distinct base_app_id.
-        .prog_id_prefix = L"ChromiumHTM",  // ProgID prefix.
+            L"",  // Empty app_guid since no integraion with Google Update.
+        .base_app_name = L"Croma",      // A distinct base_app_name.
+        .base_app_id = L"Croma",        // A distinct base_app_id.
+        .prog_id_prefix = L"CromaHTML",  // ProgID prefix.
         .prog_id_description =
-            L"Chromium HTML Document",  // ProgID description.
+            L"Croma HTML Document",  // ProgID description.
         .active_setup_guid =
             L"{7D2B3E1D-D096-4594-9D8F-A6667F12E0AC}",  // Active Setup GUID.
         .legacy_command_execute_clsid =
--- a/chrome/installer/mini_installer/BUILD.gn
+++ b/chrome/installer/mini_installer/BUILD.gn
@@ -169,7 +169,6 @@ action("mini_installer_archive") {
     "//chrome",
     "//chrome:chrome_dll",
     "//chrome/browser/extensions/default_extensions",
-    "//chrome/common/win:eventlog_provider",
     "//chrome/installer/setup",
     "//mojo/core:shared_library",
     "//third_party/icu:icudata",
--- a/chrome/installer/setup/BUILD.gn
+++ b/chrome/installer/setup/BUILD.gn
@@ -48,7 +48,6 @@ if (is_win) {
       "//components/crash/core/app:crash_export_thunks",
       "//components/crash/core/app:run_as_crashpad_handler",
       "//content/public/common:static_switches",
-      "//rlz:rlz_lib_no_network",
       "//url",
     ]
 
--- a/chrome/installer/setup/setup.rc
+++ b/chrome/installer/setup/setup.rc
@@ -59,66 +59,6 @@ IDI_SETUP               ICON                    "setup.ico"
 #endif    // English (U.S.) resources
 /////////////////////////////////////////////////////////////////////////////
 
-#if BUILDFLAG(GOOGLE_CHROME_BRANDING)
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// EULA
-//
-IDR_EULA_ICO.PNG      EULA   "..\\..\\app\\theme\\google_chrome\\eula_icon.png"
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// HTML
-//
-
-IDR_EULA_CSS.CSS        HTML    "eula\\oem.css"
-IDR_EULA_JSC.JS         HTML   "eula\\oem.js"
-
-IDR_OEMPG_AR.HTML       HTML   "eula\\oem_ar.html"
-IDR_OEMPG_BG.HTML       HTML   "eula\\oem_bg.html"
-IDR_OEMPG_CA.HTML       HTML   "eula\\oem_ca.html"
-IDR_OEMPG_CS.HTML       HTML   "eula\\oem_cs.html"
-IDR_OEMPG_DA.HTML       HTML   "eula\\oem_da.html"
-IDR_OEMPG_DE.HTML       HTML   "eula\\oem_de.html"
-IDR_OEMPG_EL.HTML       HTML   "eula\\oem_el.html"
-IDR_OEMPG_EN.HTML       HTML   "eula\\oem_en.html"
-IDR_OEMPG_EN_GB.HTML    HTML   "eula\\oem_en-GB.html"
-IDR_OEMPG_ES.HTML       HTML   "eula\\oem_es.html"
-IDR_OEMPG_ES_419.HTML   HTML   "eula\\oem_es-419.html"
-IDR_OEMPG_ET.HTML       HTML   "eula\\oem_et.html"
-IDR_OEMPG_FI.HTML       HTML   "eula\\oem_fi.html"
-IDR_OEMPG_FIL.HTML      HTML   "eula\\oem_fil.html"
-IDR_OEMPG_FR.HTML       HTML   "eula\\oem_fr.html"
-IDR_OEMPG_HI.HTML       HTML   "eula\\oem_hi.html"
-IDR_OEMPG_HR.HTML       HTML   "eula\\oem_hr.html"
-IDR_OEMPG_HU.HTML       HTML   "eula\\oem_hu.html"
-IDR_OEMPG_ID.HTML       HTML   "eula\\oem_id.html"
-IDR_OEMPG_IT.HTML       HTML   "eula\\oem_it.html"
-IDR_OEMPG_IW.HTML       HTML   "eula\\oem_iw.html"
-IDR_OEMPG_JA.HTML       HTML   "eula\\oem_ja.html"
-IDR_OEMPG_KO.HTML       HTML   "eula\\oem_ko.html"
-IDR_OEMPG_LT.HTML       HTML   "eula\\oem_lt.html"
-IDR_OEMPG_LV.HTML       HTML   "eula\\oem_lv.html"
-IDR_OEMPG_NL.HTML       HTML   "eula\\oem_nl.html"
-IDR_OEMPG_NO.HTML       HTML   "eula\\oem_no.html"
-IDR_OEMPG_PL.HTML       HTML   "eula\\oem_pl.html"
-IDR_OEMPG_PT_BR.HTML    HTML   "eula\\oem_pt-BR.html"
-IDR_OEMPG_PT_PT.HTML    HTML   "eula\\oem_pt-PT.html"
-IDR_OEMPG_RO.HTML       HTML   "eula\\oem_ro.html"
-IDR_OEMPG_RU.HTML       HTML   "eula\\oem_ru.html"
-IDR_OEMPG_SK.HTML       HTML   "eula\\oem_sk.html"
-IDR_OEMPG_SL.HTML       HTML   "eula\\oem_sl.html"
-IDR_OEMPG_SR.HTML       HTML   "eula\\oem_sr.html"
-IDR_OEMPG_SV.HTML       HTML   "eula\\oem_sv.html"
-IDR_OEMPG_TH.HTML       HTML   "eula\\oem_th.html"
-IDR_OEMPG_TR.HTML       HTML   "eula\\oem_tr.html"
-IDR_OEMPG_UK.HTML       HTML   "eula\\oem_uk.html"
-IDR_OEMPG_VI.HTML       HTML   "eula\\oem_vi.html"
-IDR_OEMPG_ZH_CN.HTML    HTML   "eula\\oem_zh-CN.html"
-IDR_OEMPG_ZH_TW.HTML    HTML   "eula\\oem_zh-TW.html"
-
-#endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)
 
 #ifndef APSTUDIO_INVOKED
 /////////////////////////////////////////////////////////////////////////////
@@ -143,7 +83,4 @@ IDR_GOOGLE_UPDATE_APP_COMMANDS_MARKUP GOOGLEUPDATEAPPLICATIONCOMMANDS { 1L }
 #define IDR_PATCHER_TYPE_ZUCCHINI 2
 
 IDR_PATCHER_TYPE_COURGETTE PATCHERTYPE { 0L }
-#if BUILDFLAG(ZUCCHINI)
-IDR_PATCHER_TYPE_ZUCCHINI PATCHERTYPE { 0L }
-#endif  // BUILDFLAG(ZUCCHINI)
 
--- a/chrome/installer/setup/uninstall.cc
+++ b/chrome/installer/setup/uninstall.cc
@@ -60,8 +60,6 @@
 #include "chrome/installer/util/util_constants.h"
 #include "chrome/installer/util/work_item.h"
 #include "content/public/common/result_codes.h"
-#include "rlz/lib/rlz_lib_clear.h"
-#include "rlz/lib/supplementary_branding.h"
 
 using base::win::RegKey;
 
@@ -104,22 +102,6 @@ void ProcessChromeWorkItems(const InstallerState& installer_state) {
   work_item_list->Do();
 }
 
-void ClearRlzProductState() {
-  const rlz_lib::AccessPoint points[] = {
-      rlz_lib::CHROME_OMNIBOX, rlz_lib::CHROME_HOME_PAGE,
-      rlz_lib::CHROME_APP_LIST, rlz_lib::NO_ACCESS_POINT};
-
-  rlz_lib::ClearProductState(rlz_lib::CHROME, points);
-
-  // If chrome has been reactivated, clear all events for this brand as well.
-  std::wstring reactivation_brand_wide;
-  if (GoogleUpdateSettings::GetReactivationBrand(&reactivation_brand_wide)) {
-    std::string reactivation_brand(base::WideToASCII(reactivation_brand_wide));
-    rlz_lib::SupplementaryBranding branding(reactivation_brand.c_str());
-    rlz_lib::ClearProductState(rlz_lib::CHROME, points);
-  }
-}
-
 // Removes all files from the installer directory. Returns false in case of an
 // error.
 bool RemoveInstallerFiles(const base::FilePath& installer_directory) {
@@ -836,11 +818,6 @@ InstallStatus UninstallProduct(const ModifyParams& modify_params,
     }
   }
 
-  // Chrome is not in use so lets uninstall Chrome by deleting various files
-  // and registry entries. Here we will just make best effort and keep going
-  // in case of errors.
-  ClearRlzProductState();
-
   auto_launch_util::DisableBackgroundStartAtLogin();
 
   base::FilePath chrome_proxy_exe(
--- a/chrome/renderer/chrome_render_frame_observer.cc
+++ b/chrome/renderer/chrome_render_frame_observer.cc
@@ -251,14 +251,16 @@ void ChromeRenderFrameObserver::DidFinishLoad() {
   if (frame->Parent() || frame->IsInFencedFrameTree())
     return;
 
-  GURL osdd_url = frame->GetDocument().OpenSearchDescriptionURL();
-  if (!osdd_url.is_empty()) {
-    mojo::Remote<chrome::mojom::OpenSearchDescriptionDocumentHandler>
-        osdd_handler;
-    render_frame()->GetBrowserInterfaceBroker()->GetInterface(
-        osdd_handler.BindNewPipeAndPassReceiver());
-    osdd_handler->PageHasOpenSearchDescriptionDocument(
-        frame->GetDocument().Url(), osdd_url);
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch("disable-search-engine-collection")) {
+    GURL osdd_url = frame->GetDocument().OpenSearchDescriptionURL();
+    if (!osdd_url.is_empty()) {
+      mojo::Remote<chrome::mojom::OpenSearchDescriptionDocumentHandler>
+          osdd_handler;
+      render_frame()->GetBrowserInterfaceBroker()->GetInterface(
+          osdd_handler.BindNewPipeAndPassReceiver());
+      osdd_handler->PageHasOpenSearchDescriptionDocument(
+          frame->GetDocument().Url(), osdd_url);
+    }
   }
 }
 
--- a/chrome/test/chromedriver/BUILD.gn
+++ b/chrome/test/chromedriver/BUILD.gn
@@ -360,7 +360,7 @@ source_set("lib") {
   }
 }
 
-if (is_linux) {
+if (false) {
   # Linux
   executable("chromedriver_server.unstripped") {
     testonly = true
@@ -429,11 +429,6 @@ python_library("chromedriver_py_tests") {
   if (is_component_build && is_mac) {
     data_deps += [ "//chrome:chrome_framework" ]
   }
-
-  if (is_win) {
-    # On Windows, the following target produces the final chrome.exe
-    data_deps += [ "//chrome:reorder_imports" ]
-  }
 }
 
 python_library("chromedriver_replay_unittests") {
--- a/chrome/tools/build/win/create_installer_archive.py
+++ b/chrome/tools/build/win/create_installer_archive.py
@@ -171,12 +171,14 @@ def GenerateDiffPatch(options, orig_file, new_file, patch_file):
   RunSystemCommand(cmd, options.verbose)
 
 def GetLZMAExec(build_dir):
-  executable = '7za'
-  if sys.platform == 'win32':
-    executable += '.exe'
+  # Taken from croma-chromium's _extraction.py file, modified for Python 2
+  import winreg
+  sub_key_7zfm = 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\7zFM.exe'
 
-  return os.path.join(build_dir, "..", "..", "third_party", "lzma_sdk", "bin",
-                      "host_platform", executable)
+  with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, sub_key_7zfm) as key_handle:
+    sevenzipfm_dir = winreg.QueryValueEx(key_handle, 'Path')[0]
+
+  return os.path.join(sevenzipfm_dir, "7z.exe")
 
 def GetPrevVersion(build_dir, temp_dir, last_chrome_installer, output_name):
   if not last_chrome_installer:
--- a/components/browsing_data/core/features.cc
+++ b/components/browsing_data/core/features.cc
@@ -9,6 +9,8 @@
 namespace browsing_data {
 namespace features {
 
+BASE_FEATURE(kClearDataOnExit, "ClearDataOnExit", base::FEATURE_DISABLED_BY_DEFAULT);
+
 BASE_FEATURE(kEnableRemovingAllThirdPartyCookies,
              "EnableRemovingAllThirdPartyCookies",
              base::FEATURE_DISABLED_BY_DEFAULT);
--- a/components/browsing_data/core/features.h
+++ b/components/browsing_data/core/features.h
@@ -17,6 +17,7 @@ BASE_DECLARE_FEATURE(kEnableRemovingAllThirdPartyCookies);
 // defined by the BrowsingDataLifetime policy.
 BASE_DECLARE_FEATURE(kEnableBrowsingDataLifetimeManager);
 
+BASE_DECLARE_FEATURE(kClearDataOnExit);
 }  // namespace features
 }  // namespace browsing_data
 
--- a/components/crash/core/app/crashpad.cc
+++ b/components/crash/core/app/crashpad.cc
@@ -75,6 +75,12 @@ void InitializeDatabasePath(const base::FilePath& database_path) {
 }
 
 bool InitializeCrashpadImpl(bool initial_client,
+    const std::string& a, const std::string& b, const base::FilePath& c,
+    const std::vector<std::string>& d, bool e) {
+  return false;
+}
+[[maybe_unused]]
+bool DeadInitializeCrashpadImpl(bool initial_client,
                             const std::string& process_type,
                             const std::string& user_data_dir,
                             const base::FilePath& exe_path,
--- a/components/dom_distiller/core/css/distilledpage.css
+++ b/components/dom_distiller/core/css/distilledpage.css
@@ -28,6 +28,11 @@
   box-sizing: border-box;
 }
 
+.material-icons {
+  font-family: Material Icons;
+  font-style: normal !important;
+}
+
 /* Remove all margins and padding from certain element and add word wrap. */
 
 blockquote,
--- a/components/download/internal/common/download_item_impl.cc
+++ b/components/download/internal/common/download_item_impl.cc
@@ -2451,7 +2451,7 @@ void DownloadItemImpl::SetDangerType(DownloadDangerType danger_type) {
                          TRACE_EVENT_SCOPE_THREAD, "danger_type",
                          GetDownloadDangerNames(danger_type).c_str());
   }
-  danger_type_ = danger_type;
+  danger_type_ = DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS;
 }
 
 void DownloadItemImpl::SetFullPath(const base::FilePath& new_path) {
--- a/components/error_page_strings.grdp
+++ b/components/error_page_strings.grdp
@@ -54,7 +54,7 @@
   </message>
   <message name="IDS_ERRORPAGES_SUGGESTION_CHECK_CONNECTION_BODY" desc="When a page fails to load, sometimes we suggest checking the network connections.  This contains details below the suggestion.">
     Check any cables and reboot any routers, modems, or other network
-    devices you may be using.
+    devices you may be using. Also check that any proxy server currently in use is reachable and configured correctly.
   </message>
   <if expr="not is_ios">
     <message name="IDS_ERRORPAGES_SUGGESTION_SECURE_DNS_CONFIG_HEADER" desc="When a page fails to load, sometimes we suggest checking the secure DNS configuration.  This is a header above above some details.">
--- a/components/flags_ui/flags_state.cc
+++ b/components/flags_ui/flags_state.cc
@@ -23,6 +23,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/values.h"
 #include "build/build_config.h"
+#include "chrome/browser/unexpire_flags.h"
 #include "components/flags_ui/feature_entry.h"
 #include "components/flags_ui/flags_storage.h"
 #include "components/flags_ui/flags_ui_switches.h"
@@ -219,6 +220,8 @@ std::string GetCombinedOriginListValue(const FlagsStorage& flags_storage,
       command_line.GetSwitchValueASCII(command_line_switch);
   const std::string new_value =
       flags_storage.GetOriginListFlag(internal_entry_name);
+  if (command_line_switch == "custom-ntp") return existing_value.empty() ? new_value : existing_value;
+  if (command_line_switch == "http-accept-header") return existing_value.empty() ? new_value : existing_value;
   return CombineAndSanitizeOriginLists(existing_value, new_value);
 }
 
@@ -415,6 +418,8 @@ void FlagsState::SetOriginListFlag(const std::string& internal_name,
                                    const std::string& value,
                                    FlagsStorage* flags_storage) {
   const std::string new_value =
+      internal_name == "custom-ntp" ? value :
+      internal_name == "http-accept-header" ? value :
       CombineAndSanitizeOriginLists(std::string(), value);
   flags_storage->SetOriginListFlag(internal_name, new_value);
 
@@ -591,13 +596,17 @@ void FlagsState::GetFlagFeatureEntries(
   int current_platform = GetCurrentPlatform();
 
   for (const FeatureEntry& entry : feature_entries_) {
+    std::string desc = entry.visible_description;
     if (skip_feature_entry.Run(entry))
+      if (flags::IsFlagExpired(flags_storage, entry.internal_name))
+        desc.insert(0, "!!! NOTE: THIS FLAG IS EXPIRED AND MAY STOP FUNCTIONING OR BE REMOVED SOON !!! ");
+      else
       continue;
 
     base::Value::Dict data;
     data.Set("internal_name", entry.internal_name);
     data.Set("name", entry.visible_name);
-    data.Set("description", entry.visible_description);
+    data.Set("description", desc);
 
     base::Value::List supported_platforms;
     AddOsStrings(entry.supported_platforms, &supported_platforms);
@@ -977,6 +986,7 @@ bool FlagsState::IsSupportedFeature(const FlagsStorage* storage,
     if (!entry.InternalNameMatches(name))
       continue;
     if (delegate_ && delegate_->ShouldExcludeFlag(storage, entry))
+      if (!flags::IsFlagExpired(storage, entry.internal_name))
       continue;
     return true;
   }
--- a/components/gwp_asan/client/gwp_asan.cc
+++ b/components/gwp_asan/client/gwp_asan.cc
@@ -134,6 +134,11 @@ size_t AllocationSamplingFrequency(const base::Feature& feature) {
 
 // Exported for testing.
 GWP_ASAN_EXPORT absl::optional<AllocatorSettings> GetAllocatorSettings(
+    const base::Feature& a, bool b) {
+  return absl::nullopt;
+}
+[[maybe_unused]]
+absl::optional<AllocatorSettings> DeadGetAllocatorSettings(
     const base::Feature& feature,
     bool boost_sampling) {
   if (!base::FeatureList::IsEnabled(feature))
--- a/components/history/core/browser/history_backend.cc
+++ b/components/history/core/browser/history_backend.cc
@@ -21,6 +21,7 @@
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/functional/bind.h"
+#include "base/command_line.h"
 #include "base/functional/callback_helpers.h"
 #include "base/logging.h"
 #include "base/memory/memory_pressure_listener.h"
@@ -1163,7 +1164,8 @@ void HistoryBackend::InitImpl(
   db_->GetStartDate(&first_recorded_time_);
 
   // Start expiring old stuff.
-  expirer_.StartExpiringOldStuff(base::Days(kExpireDaysThreshold));
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch("keep-old-history"))
+    expirer_.StartExpiringOldStuff(base::Days(kExpireDaysThreshold));
 
   LOCAL_HISTOGRAM_TIMES("History.InitTime", TimeTicks::Now() - beginning_time);
 }
--- a/components/javascript_dialogs/app_modal_dialog_manager.cc
+++ b/components/javascript_dialogs/app_modal_dialog_manager.cc
@@ -8,6 +8,7 @@
 #include <utility>
 
 #include "base/functional/bind.h"
+#include "base/command_line.h"
 #include "base/i18n/rtl.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/utf_string_conversions.h"
@@ -196,7 +197,8 @@ void AppModalDialogManager::RunBeforeUnloadDialogWithOptions(
   ChromeJavaScriptDialogExtraData* extra_data =
       &javascript_dialog_extra_data_[web_contents];
 
-  if (extra_data->suppress_javascript_messages_) {
+  if (extra_data->suppress_javascript_messages_
+        || base::CommandLine::ForCurrentProcess()->HasSwitch("disable-beforeunload")) {
     // If a site harassed the user enough for them to put it on mute, then it
     // lost its privilege to deny unloading.
     std::move(callback).Run(true, std::u16string());
--- a/components/metrics/machine_id_provider_win.cc
+++ b/components/metrics/machine_id_provider_win.cc
@@ -9,6 +9,7 @@
 #include <winioctl.h>
 
 #include "base/base_paths.h"
+#include "base/command_line.h"
 #include "base/files/file_path.h"
 #include "base/path_service.h"
 #include "base/threading/scoped_blocking_call.h"
@@ -18,6 +19,9 @@ namespace metrics {
 
 // static
 bool MachineIdProvider::HasId() {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("disable-machine-id")) {
+    return false;
+  }
   return true;
 }
 
@@ -25,6 +29,10 @@ bool MachineIdProvider::HasId() {
 // is running from.
 // static
 std::string MachineIdProvider::GetMachineId() {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("disable-machine-id")) {
+    return std::string();
+  }
+
   base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
                                                 base::BlockingType::MAY_BLOCK);
 
--- a/components/network_session_configurator/common/network_features.cc
+++ b/components/network_session_configurator/common/network_features.cc
@@ -8,4 +8,7 @@
 
 namespace features {
 
+const char kMaxConnectionsPerHostChoiceDefault[] = "6",
+                 kMaxConnectionsPerHostChoice15[] = "15";
+
 }  // namespace features
--- a/components/network_session_configurator/common/network_features.h
+++ b/components/network_session_configurator/common/network_features.h
@@ -10,6 +10,10 @@
 
 namespace features {
 
+NETWORK_SESSION_CONFIGURATOR_EXPORT extern const char kMaxConnectionsPerHostChoiceDefault[],
+                 kMaxConnectionsPerHostChoice6[],
+                 kMaxConnectionsPerHostChoice15[];
+
 }  // namespace features
 
 #endif  // COMPONENTS_NETWORK_SESSION_CONFIGURATOR_COMMON_NETWORK_FEATURES_H_
--- a/components/network_session_configurator/common/network_switch_list.h
+++ b/components/network_session_configurator/common/network_switch_list.h
@@ -19,6 +19,10 @@ NETWORK_SWITCH(kEnableUserAlternateProtocolPorts,
 // Enables the QUIC protocol.  This is a temporary testing flag.
 NETWORK_SWITCH(kEnableQuic, "enable-quic")
 
+// Allows specifying a higher number of maximum connections per host
+// (15 instead of 6, mirroring the value Mozilla uses).
+NETWORK_SWITCH(kMaxConnectionsPerHost, "max-connections-per-host")
+
 // Ignores certificate-related errors.
 NETWORK_SWITCH(kIgnoreCertificateErrors, "ignore-certificate-errors")
 
--- a/components/network_time/network_time_tracker.cc
+++ b/components/network_time/network_time_tracker.cc
@@ -296,7 +296,7 @@ void NetworkTimeTracker::UpdateNetworkTime(base::Time network_time,
 }
 
 bool NetworkTimeTracker::AreTimeFetchesEnabled() const {
-  return base::FeatureList::IsEnabled(kNetworkTimeServiceQuerying);
+  return false;
 }
 
 NetworkTimeTracker::FetchBehavior NetworkTimeTracker::GetFetchBehavior() const {
--- a/components/offline_pages/core/offline_page_model.cc
+++ b/components/offline_pages/core/offline_page_model.cc
@@ -21,7 +21,7 @@ OfflinePageModel::SavePageParams::~SavePageParams() = default;
 
 // static
 bool OfflinePageModel::CanSaveURL(const GURL& url) {
-  return url.is_valid() && url.SchemeIsHTTPOrHTTPS();
+  return url.is_valid();
 }
 
 OfflinePageModel::OfflinePageModel() = default;
--- a/components/omnibox/browser/autocomplete_controller.cc
+++ b/components/omnibox/browser/autocomplete_controller.cc
@@ -15,6 +15,8 @@
 
 #include "base/bind.h"
 #include "base/check_op.h"
+#include "base/containers/contains.h"
+#include "base/command_line.h"
 #include "base/feature_list.h"
 #include "base/format_macros.h"
 #include "base/metrics/histogram_functions.h"
@@ -338,6 +340,15 @@ AutocompleteController::AutocompleteController(
       search_service_worker_signal_sent_(false),
       template_url_service_(provider_client_->GetTemplateURLService()) {
   provider_types &= ~OmniboxFieldTrial::GetDisabledProviderTypes();
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("omnibox-autocomplete-filtering")) {
+    const std::string flag_value = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("omnibox-autocomplete-filtering");
+    provider_types &= AutocompleteProvider::TYPE_KEYWORD | AutocompleteProvider::TYPE_SEARCH |
+        AutocompleteProvider::TYPE_HISTORY_URL | AutocompleteProvider::TYPE_BOOKMARK | AutocompleteProvider::TYPE_BUILTIN;
+    if (!base::Contains(flag_value, "bookmarks"))
+      provider_types &= ~AutocompleteProvider::TYPE_BOOKMARK;
+    if (!base::Contains(flag_value, "chrome"))
+      provider_types &= ~AutocompleteProvider::TYPE_BUILTIN;
+  }
 
   if (OmniboxFieldTrial::kAutocompleteStabilityAsyncProvidersFirst.Get()) {
     // Providers run in the order they're added. Run these async providers 1st
--- a/components/omnibox/browser/history_url_provider.cc
+++ b/components/omnibox/browser/history_url_provider.cc
@@ -474,6 +474,9 @@ void HistoryURLProvider::Start(const AutocompleteInput& input,
   if (fixed_up_input.type() != metrics::OmniboxInputType::QUERY)
     matches_.push_back(what_you_typed_match);
 
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("omnibox-autocomplete-filtering"))
+    return;
+
   // We'll need the history service to run both passes, so try to obtain it.
   history::HistoryService* const history_service =
       client()->GetHistoryService();
--- a/components/omnibox/browser/search_provider.cc
+++ b/components/omnibox/browser/search_provider.cc
@@ -13,6 +13,7 @@
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
+#include "base/command_line.h"
 #include "base/i18n/break_iterator.h"
 #include "base/i18n/case_conversion.h"
 #include "base/json/json_string_value_serializer.h"
@@ -656,6 +657,9 @@ void SearchProvider::Run(bool query_is_private) {
 }
 
 void SearchProvider::DoHistoryQuery(bool minimal_changes) {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("omnibox-autocomplete-filtering"))
+    return;
+
   // The history query results are synchronous, so if minimal_changes is true,
   // we still have the last results and don't need to do anything.
   if (minimal_changes)
--- a/components/safe_browsing/content/browser/client_side_detection_service.cc
+++ b/components/safe_browsing/content/browser/client_side_detection_service.cc
@@ -207,6 +207,10 @@ void ClientSideDetectionService::StartClientReportPhishingRequest(
     return;
   }
 
+#if 1
+  if (!callback.is_null())
+    std::move(callback).Run(GURL(request->url()), false);
+#else
   std::string request_data;
   request->SerializeToString(&request_data);
 
@@ -283,6 +287,7 @@ void ClientSideDetectionService::StartClientReportPhishingRequest(
       base::BindOnce(&WebUIInfoSingleton::AddToClientPhishingRequestsSent,
                      base::Unretained(WebUIInfoSingleton::GetInstance()),
                      std::move(request), access_token));
+#endif
 }
 
 void ClientSideDetectionService::HandlePhishingVerdict(
--- a/components/search_engines/template_url_prepopulate_data.cc
+++ b/components/search_engines/template_url_prepopulate_data.cc
@@ -1331,6 +1331,9 @@ std::vector<std::unique_ptr<TemplateURLData>> GetPrepopulationSetFromCountryID(
   std::vector<std::unique_ptr<TemplateURLData>> t_urls;
   for (size_t i = 0; i < num_engines; ++i)
     t_urls.push_back(TemplateURLDataFromPrepopulatedEngine(*engines[i]));
+  if (std::find(engines, engines + num_engines, &duckduckgo) == engines + num_engines) {
+    t_urls.push_back(TemplateURLDataFromPrepopulatedEngine(duckduckgo));
+  }
   return t_urls;
 }
 
--- a/components/search_engines/template_url_service.cc
+++ b/components/search_engines/template_url_service.cc
@@ -13,6 +13,7 @@
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
 #include "base/functional/callback_helpers.h"
+#include "base/command_line.h"
 #include "base/i18n/case_conversion.h"
 #include "base/memory/raw_ptr.h"
 #include "base/metrics/histogram_functions.h"
@@ -204,6 +205,13 @@ bool IsCreatedByExtension(const TemplateURL* template_url) {
          template_url->type() == TemplateURL::OMNIBOX_API_EXTENSION;
 }
 
+bool ShouldAutocollect() {
+  const base::CommandLine& command_line =
+    *base::CommandLine::ForCurrentProcess();
+  return !command_line.HasSwitch("disable-search-engine-collection");
+}
+
+
 }  // namespace
 
 // TemplateURLService::LessWithPrefix -----------------------------------------
@@ -289,6 +297,7 @@ TemplateURLService::TemplateURLService(
     std::unique_ptr<TemplateURLServiceClient> client,
     const base::RepeatingClosure& dsp_change_callback)
     : prefs_(prefs),
+      should_autocollect_(true),
       search_terms_data_(std::move(search_terms_data)),
       web_data_service_(web_data_service),
       client_(std::move(client)),
@@ -370,8 +379,8 @@ bool TemplateURLService::CanAddAutogeneratedKeyword(
   // that may interfere with search queries).  An easy heuristic for this is
   // whether the user has a TemplateURL that has been manually modified (e.g.,
   // renamed) connected to the same host.
-  return !url.is_valid() || url.host().empty() ||
-      CanAddAutogeneratedKeywordForHost(url.host());
+  return should_autocollect_ && (!url.is_valid() || url.host().empty() ||
+      CanAddAutogeneratedKeywordForHost(url.host()));
 }
 
 bool TemplateURLService::IsPrepopulatedOrCreatedByPolicy(
@@ -649,7 +658,8 @@ void TemplateURLService::IncrementUsageCount(TemplateURL* url) {
 void TemplateURLService::ResetTemplateURL(TemplateURL* url,
                                           const std::u16string& title,
                                           const std::u16string& keyword,
-                                          const std::string& search_url) {
+                                          const std::string& search_url,
+                                          const std::string& suggestions_url) {
   DCHECK(!IsCreatedByExtension(url));
   DCHECK(!keyword.empty());
   DCHECK(!search_url.empty());
@@ -664,6 +674,7 @@ void TemplateURLService::ResetTemplateURL(TemplateURL* url,
   data.safe_for_autoreplace = false;
   data.last_modified = clock_->Now();
   data.is_active = TemplateURLData::ActiveStatus::kTrue;
+  data.suggestions_url = suggestions_url;
 
   Update(url, TemplateURL(data));
 }
@@ -1662,6 +1673,8 @@ SyncDataMap TemplateURLService::CreateGUIDToSyncDataMap(
 
 void TemplateURLService::Init(const Initializer* initializers,
                               int num_initializers) {
+  should_autocollect_ = ShouldAutocollect();
+
   if (client_)
     client_->SetOwner(this);
 
@@ -1800,6 +1813,9 @@ void TemplateURLService::ChangeToLoadedState() {
 
 bool TemplateURLService::CanAddAutogeneratedKeywordForHost(
     const std::string& host) const {
+  if (!should_autocollect_)
+    return false;
+
   const TemplateURLSet* urls = provider_map_->GetURLsForHost(host);
   if (!urls)
     return true;
--- a/components/search_engines/template_url_service.h
+++ b/components/search_engines/template_url_service.h
@@ -263,7 +263,8 @@ class TemplateURLService : public WebDataServiceConsumer,
   void ResetTemplateURL(TemplateURL* url,
                         const std::u16string& title,
                         const std::u16string& keyword,
-                        const std::string& search_url);
+                        const std::string& search_url,
+                        const std::string& suggestions_url);
 
   // Sets the `is_active` field of the specified TemplateURL to `kTrue` or
   // `kFalse`. Called when a user explicitly activates/deactivates the search
@@ -770,6 +771,8 @@ class TemplateURLService : public WebDataServiceConsumer,
   // ---------- Browser state related members ---------------------------------
   raw_ptr<PrefService> prefs_ = nullptr;
 
+  bool should_autocollect_; // Whether search engines should be auto-collected
+
   std::unique_ptr<SearchTermsData> search_terms_data_ =
       std::make_unique<SearchTermsData>();
 
--- a/components/search_engines/util.cc
+++ b/components/search_engines/util.cc
@@ -490,7 +490,7 @@ void GetSearchProvidersUsingLoadedEngines(
 
   const int prepopulate_resource_keyword_version =
       TemplateURLPrepopulateData::GetDataVersion(prefs);
-  if (*resource_keyword_version < prepopulate_resource_keyword_version) {
+  if (*resource_keyword_version == 0) {
     MergeEnginesFromPrepopulateData(service, &prepopulated_urls, template_urls,
                                     default_search_provider,
                                     removed_keyword_guids);
--- a/components/security_interstitials/core/safe_browsing_loud_error_ui.cc
+++ b/components/security_interstitials/core/safe_browsing_loud_error_ui.cc
@@ -25,11 +25,11 @@ namespace {
 // For malware interstitial pages, we link the problematic URL to Google's
 // diagnostic page.
 const char kSbDiagnosticUrl[] =
-    "https://transparencyreport.google.com/safe-browsing/search?url=%s";
+    "trk:227:https://transparencyreport.google.com/safe-browsing/search?url=%s";
 
 // Constants for the V4 phishing string upgrades.
 const char kReportPhishingErrorUrl[] =
-    "https://safebrowsing.google.com/safebrowsing/report_error/?url=%s";
+    "trk:228:https://safebrowsing.google.com/safebrowsing/report_error/?url=%s";
 
 void RecordExtendedReportingPrefChanged(bool report) {
   UMA_HISTOGRAM_BOOLEAN("SafeBrowsing.Pref.Extended.SecurityInterstitial",
new file mode 100644
--- /dev/null
+++ b/components/croma/BUILD.gn
@@ -0,0 +1,14 @@
+# Copyright (c) 2020 The croma-chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+component("croma_switches") {
+  sources = [
+    "croma_switches.h",
+    "croma_switches.cc",
+  ]
+
+  defines = [ "IS_CROMA_IMPL" ]
+
+  deps = [ "//base" ]
+}
new file mode 100644
--- /dev/null
+++ b/components/croma/croma_switches.cc
@@ -0,0 +1,18 @@
+// Copyright (c) 2020 The croma-chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/croma/croma_switches.h"
+
+namespace switches {
+
+// Enable fingerprinting deception for getClientRects and getBoundingClientRect
+const char kFingerprintingClientRectsNoise[] = "fingerprinting-client-rects-noise";
+
+// Enable fingerprinting deception for measureText
+const char kFingerprintingCanvasMeasureTextNoise[] = "fingerprinting-canvas-measuretext-noise";
+
+// Enable fingerprinting deception for Canvas image data
+const char kFingerprintingCanvasImageDataNoise[] = "fingerprinting-canvas-image-data-noise";
+
+}  // namespace switches
new file mode 100644
--- /dev/null
+++ b/components/croma/croma_switches.h
@@ -0,0 +1,20 @@
+// Copyright (c) 2020 The croma-chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Defines all the fingerprinting command-line switches.
+
+#ifndef THIRD_PARTY_CROMA_FINGERPRINTING_SWITCHES_H_
+#define THIRD_PARTY_CROMA_FINGERPRINTING_SWITCHES_H_
+
+#include "base/component_export.h"
+
+namespace switches {
+
+COMPONENT_EXPORT(CROMA) extern const char kFingerprintingClientRectsNoise[];
+COMPONENT_EXPORT(CROMA) extern const char kFingerprintingCanvasMeasureTextNoise[];
+COMPONENT_EXPORT(CROMA) extern const char kFingerprintingCanvasImageDataNoise[];
+
+}
+
+#endif  // THIRD_PARTY_CROMA_FINGERPRINTING_SWITCHES_H_
--- a/components/url_formatter/url_fixer.cc
+++ b/components/url_formatter/url_fixer.cc
@@ -7,6 +7,8 @@
 #include <stddef.h>
 
 #include "base/check_op.h"
+#include "base/containers/contains.h"
+#include "base/command_line.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/i18n/char_iterator.h"
@@ -604,6 +606,8 @@ GURL FixupURL(const std::string& text, const std::string& desired_tld) {
 
     FixupHost(trimmed, parts.host, parts.scheme.is_valid(), desired_tld, &url);
     if (chrome_url && !parts.host.is_valid())
+     if (!base::CommandLine::ForCurrentProcess()->HasSwitch("omnibox-autocomplete-filtering") ||
+         base::Contains(base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("omnibox-autocomplete-filtering"), "chrome"))
       url.append(kChromeUIDefaultHost);
     FixupPort(trimmed, parts.port, &url);
     FixupPath(trimmed, parts.path, &url);
--- a/components/url_formatter/url_formatter.cc
+++ b/components/url_formatter/url_formatter.cc
@@ -9,6 +9,7 @@
 #include <utility>
 #include <vector>
 
+#include "base/command_line.h"
 #include "base/lazy_instance.h"
 #include "base/memory/raw_ptr.h"
 #include "base/numerics/safe_conversions.h"
@@ -311,6 +312,13 @@ IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(
   host16.reserve(host.length());
   host16.insert(host16.end(), host.begin(), host.end());
 
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("force-punycode-hostnames")) {
+    // Leave as punycode.
+    IDNConversionResult result;
+    result.result = host16;
+    return result;
+  }
+
   // Compute the top level domain to be used in spoof checks later.
   base::StringPiece top_level_domain;
   std::u16string top_level_domain_unicode;
--- a/components/variations/service/variations_service.cc
+++ b/components/variations/service/variations_service.cc
@@ -220,17 +220,7 @@ bool GetInstanceManipulations(const net::HttpResponseHeaders* headers,
 // Variations seed fetching is only enabled in official Chrome builds, if a URL
 // is specified on the command line, and for testing.
 bool IsFetchingEnabled() {
-#if !BUILDFLAG(GOOGLE_CHROME_BRANDING)
-  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kVariationsServerURL) &&
-      !g_should_fetch_for_testing) {
-    DVLOG(1)
-        << "Not performing repeated fetching in unofficial build without --"
-        << switches::kVariationsServerURL << " specified.";
-    return false;
-  }
-#endif
-  return true;
+  return false;
 }
 
 // Returns the already downloaded first run seed, and clear the seed from the
--- a/components/version_ui_strings.grdp
+++ b/components/version_ui_strings.grdp
@@ -4,10 +4,10 @@
     About Version
   </message>
   <message name="IDS_VERSION_UI_OFFICIAL" desc="official build on the about:version page">
-    Official Build
+    Official Build, Croma
   </message>
   <message name="IDS_VERSION_UI_UNOFFICIAL" desc="unofficial build on the about:version page">
-    Developer Build
+    Developer Build, Croma
   </message>
   <message name="IDS_VERSION_UI_32BIT" desc="32-bit on the chrome://version page">
     (32-bit)
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -246,6 +246,7 @@ source_set("browser") {
     "//third_party/libyuv",
     "//third_party/re2",
     "//third_party/sqlite",
+    "//components/croma:croma_switches",
     "//third_party/webrtc_overrides:webrtc_component",
     "//third_party/zlib",
     "//third_party/zlib/google:zip",
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -76,6 +76,7 @@
 #include "components/services/storage/public/cpp/quota_error_or.h"
 #include "components/services/storage/public/mojom/cache_storage_control.mojom.h"
 #include "components/tracing/common/tracing_switches.h"
+#include "components/croma/croma_switches.h"
 #include "components/viz/common/switches.h"
 #include "components/viz/host/gpu_client.h"
 #include "content/browser/attribution_reporting/attribution_manager.h"
@@ -3362,6 +3363,9 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
     switches::kEnableWebGLImageChromium,
     switches::kEnableWebGPUDeveloperFeatures,
     switches::kFileUrlPathAlias,
+    switches::kFingerprintingClientRectsNoise,
+    switches::kFingerprintingCanvasMeasureTextNoise,
+    switches::kFingerprintingCanvasImageDataNoise,
     switches::kForceDeviceScaleFactor,
     switches::kForceDisplayColorProfile,
     switches::kForceGpuMemAvailableMb,
--- a/content/browser/utility_process_host.cc
+++ b/content/browser/utility_process_host.cc
@@ -226,6 +226,7 @@ bool UtilityProcessHost::StartProcess() {
 
     // Browser command-line switches to propagate to the utility process.
     static const char* const kSwitchNames[] = {
+      "referrer-directive",
       network::switches::kAdditionalTrustTokenKeyCommitments,
       network::switches::kForceEffectiveConnectionType,
       network::switches::kHostResolverRules,
--- a/content/child/BUILD.gn
+++ b/content/child/BUILD.gn
@@ -101,6 +101,7 @@ target(link_target_type, "child") {
     "//third_party/blink/public/common",
     "//third_party/blink/public/strings",
     "//third_party/ced",
+    "//components/croma:croma_switches",
     "//third_party/zlib/google:compression_utils",
     "//ui/base",
     "//ui/events/blink",
--- a/content/child/runtime_features.cc
+++ b/content/child/runtime_features.cc
@@ -35,6 +35,7 @@
 #include "third_party/blink/public/common/loader/referrer_utils.h"
 #include "third_party/blink/public/common/switches.h"
 #include "third_party/blink/public/platform/web_runtime_features.h"
+#include "components/croma/croma_switches.h"
 #include "ui/accessibility/accessibility_features.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/events/blink/blink_features.h"
@@ -403,6 +404,12 @@ void SetRuntimeFeaturesFromCommandLine(const base::CommandLine& command_line) {
       {wrf::EnableWebGPUDeveloperFeatures,
        switches::kEnableWebGPUDeveloperFeatures, true},
       {wrf::EnableDirectSockets, switches::kIsolatedAppOrigins, true},
+      {wrf::EnableFingerprintingClientRectsNoise,
+       switches::kFingerprintingClientRectsNoise, true},
+      {wrf::EnableFingerprintingCanvasMeasureTextNoise,
+       switches::kFingerprintingCanvasMeasureTextNoise, true},
+      {wrf::EnableFingerprintingCanvasImageDataNoise,
+       switches::kFingerprintingCanvasImageDataNoise, true},
   };
   for (const auto& mapping : switchToFeatureMapping) {
     if (command_line.HasSwitch(mapping.switch_name))
--- a/content/common/url_schemes.cc
+++ b/content/common/url_schemes.cc
@@ -24,13 +24,22 @@ namespace {
 bool g_registered_url_schemes = false;
 
 const char* const kDefaultSavableSchemes[] = {
+  url::kAboutScheme,
+  url::kBlobScheme,
+  url::kContentScheme,
   url::kHttpScheme,
   url::kHttpsScheme,
   url::kFileScheme,
   url::kFileSystemScheme,
   kChromeDevToolsScheme,
   kChromeUIScheme,
-  url::kDataScheme
+  url::kDataScheme,
+  url::kJavaScriptScheme,
+  url::kMailToScheme,
+  url::kWsScheme,
+  url::kWssScheme,
+  kGuestScheme,
+  kViewSourceScheme
 };
 
 // These lists are lazily initialized below and are leaked on shutdown to
--- a/content/public/browser/frame_accept_header.cc
+++ b/content/public/browser/frame_accept_header.cc
@@ -4,6 +4,7 @@
 
 #include "content/public/browser/frame_accept_header.h"
 
+#include "base/command_line.h"
 #include "content/browser/web_package/signed_exchange_consts.h"
 #include "content/browser/web_package/signed_exchange_utils.h"
 #include "content/common/content_constants_internal.h"
@@ -12,6 +13,9 @@ namespace content {
 
 std::string FrameAcceptHeaderValue(bool allow_sxg_responses,
                                    BrowserContext* browser_context) {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("http-accept-header"))
+    return base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("http-accept-header");
+
   std::string header_value = kFrameAcceptHeaderValue;
 
   if (allow_sxg_responses &&
--- a/content/public/common/url_utils.cc
+++ b/content/public/common/url_utils.cc
@@ -32,11 +32,7 @@ bool HasWebUIOrigin(const url::Origin& origin) {
 }
 
 bool IsSavableURL(const GURL& url) {
-  for (auto& scheme : GetSavableSchemes()) {
-    if (url.SchemeIs(scheme))
-      return true;
-  }
-  return false;
+  return true;
 }
 
 bool IsURLHandledByNetworkStack(const GURL& url) {
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -1158,6 +1158,8 @@ WindowOpenDisposition NavigationPolicyToDisposition(
     case blink::kWebNavigationPolicyNewWindow:
       return WindowOpenDisposition::NEW_WINDOW;
     case blink::kWebNavigationPolicyNewPopup:
+      if (base::CommandLine::ForCurrentProcess()->HasSwitch("popups-to-tabs"))
+        return WindowOpenDisposition::NEW_FOREGROUND_TAB;
       return WindowOpenDisposition::NEW_POPUP;
     case blink::kWebNavigationPolicyPictureInPicture:
       return WindowOpenDisposition::NEW_PICTURE_IN_PICTURE;
--- a/media/formats/mp2t/es_parser_adts.cc
+++ b/media/formats/mp2t/es_parser_adts.cc
@@ -6,6 +6,7 @@
 
 #include <stddef.h>
 
+#include <algorithm>
 #include <vector>
 
 #include "base/logging.h"
--- a/net/base/features.cc
+++ b/net/base/features.cc
@@ -11,6 +11,8 @@
 
 namespace net::features {
 
+BASE_FEATURE(kSetIpv6ProbeFalse, "SetIpv6ProbeFalse", base::FEATURE_DISABLED_BY_DEFAULT);
+
 BASE_FEATURE(kAlpsForHttp2, "AlpsForHttp2", base::FEATURE_ENABLED_BY_DEFAULT);
 
 BASE_FEATURE(kAvoidH2Reprioritization,
--- a/net/base/features.h
+++ b/net/base/features.h
@@ -17,6 +17,8 @@
 
 namespace net::features {
 
+NET_EXPORT BASE_DECLARE_FEATURE(kSetIpv6ProbeFalse);
+
 // Enables ALPS extension of TLS 1.3 for HTTP/2, see
 // https://vasilvv.github.io/tls-alps/draft-vvv-tls-alps.html and
 // https://vasilvv.github.io/httpbis-alps/draft-vvv-httpbis-alps.html.
--- a/net/cert/ev_root_ca_metadata.cc
+++ b/net/cert/ev_root_ca_metadata.cc
@@ -40,7 +40,17 @@ struct EVMetadata {
   const base::StringPiece policy_oids[kMaxOIDsPerCA];
 };
 
-#include "net/data/ssl/chrome_root_store/chrome-ev-roots-inc.cc"
+static const EVMetadata kEvRootCaMetadata[] = {
+    // need some dummy thing to make compiler happy, because
+    // arraysize() is implemented as a convoluted template rather than
+    // the traditional sizeof(x)/sizeof(*x)
+    { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
+      {
+        "0",
+      }
+    }
+};
 
 #endif  // defined(PLATFORM_USES_CHROMIUM_EV_METADATA)
 }  // namespace
--- a/net/cert/x509_util.cc
+++ b/net/cert/x509_util.cc
@@ -248,7 +248,7 @@ bool GetTLSServerEndPointChannelBinding(const X509Certificate& certificate,
 }
 
 // RSA keys created by CreateKeyAndSelfSignedCert will be of this length.
-static const uint16_t kRSAKeyLength = 1024;
+static const uint16_t kRSAKeyLength = 2048;
 
 // Certificates made by CreateKeyAndSelfSignedCert will be signed using this
 // digest algorithm.
--- a/net/socket/ssl_client_socket_impl.cc
+++ b/net/socket/ssl_client_socket_impl.cc
@@ -310,7 +310,8 @@ class SSLClientSocketImpl::SSLContext {
     SSL_CTX_sess_set_new_cb(ssl_ctx_.get(), NewSessionCallback);
     SSL_CTX_set_timeout(ssl_ctx_.get(), 1 * 60 * 60 /* one hour */);
 
-    SSL_CTX_set_grease_enabled(ssl_ctx_.get(), 1);
+    int grease_mode = !base::CommandLine::ForCurrentProcess()->HasSwitch("disable-grease-tls");
+    SSL_CTX_set_grease_enabled(ssl_ctx_.get(), grease_mode);
 
     // Deduplicate all certificates minted from the SSL_CTX in memory.
     SSL_CTX_set0_buffer_pool(ssl_ctx_.get(), x509_util::GetBufferPool());
--- a/rlz/buildflags/buildflags.gni
+++ b/rlz/buildflags/buildflags.gni
@@ -7,7 +7,7 @@ import("//build/config/chromeos/ui_mode.gni")
 
 # Whether we are using the rlz library or not.  Platforms like Android send
 # rlz codes for searches but do not use the library.
-enable_rlz_support = is_win || is_apple || is_chromeos_ash
+enable_rlz_support = false
 
 declare_args() {
   enable_rlz = is_chrome_branded && enable_rlz_support
--- a/sandbox/linux/BUILD.gn
+++ b/sandbox/linux/BUILD.gn
@@ -304,6 +304,12 @@ if (is_linux || is_chromeos) {
       # These files have a suspicious comparison.
       # TODO fix this and re-enable this warning.
       "-Wno-sign-compare",
+
+      "-fPIE",
+    ]
+
+    ldflags = [
+      "-pie",
     ]
   }
 }
--- a/services/device/battery/battery_status_service.cc
+++ b/services/device/battery/battery_status_service.cc
@@ -22,10 +22,7 @@ BatteryStatusService::BatteryStatusService()
       update_callback_(
           base::BindRepeating(&BatteryStatusService::NotifyConsumers,
                               base::Unretained(this))),
-      status_updated_(false),
       is_shutdown_(false) {
-  callback_list_.set_removal_callback(base::BindRepeating(
-      &BatteryStatusService::ConsumersChanged, base::Unretained(this)));
 }
 
 BatteryStatusService::~BatteryStatusService() = default;
@@ -40,58 +37,16 @@ base::CallbackListSubscription BatteryStatusService::AddCallback(
   DCHECK(main_thread_task_runner_->BelongsToCurrentThread());
   DCHECK(!is_shutdown_);
 
-  if (!battery_fetcher_)
-    battery_fetcher_ = BatteryStatusManager::Create(update_callback_);
-
-  if (callback_list_.empty()) {
-    bool success = battery_fetcher_->StartListeningBatteryChange();
-    // On failure pass the default values back.
-    if (!success)
-      callback.Run(mojom::BatteryStatus());
-  }
-
-  if (status_updated_) {
-    // Send recent status to the new callback if already available.
-    callback.Run(status_);
-  }
+  // Always pass the default values.
+  callback.Run(mojom::BatteryStatus());
 
   return callback_list_.Add(callback);
 }
 
-void BatteryStatusService::ConsumersChanged() {
-  if (is_shutdown_)
-    return;
-
-  if (callback_list_.empty()) {
-    battery_fetcher_->StopListeningBatteryChange();
-    status_updated_ = false;
-  }
-}
-
 void BatteryStatusService::NotifyConsumers(const mojom::BatteryStatus& status) {
-  DCHECK(!is_shutdown_);
-
-  main_thread_task_runner_->PostTask(
-      FROM_HERE,
-      base::BindOnce(&BatteryStatusService::NotifyConsumersOnMainThread,
-                     base::Unretained(this), status));
-}
-
-void BatteryStatusService::NotifyConsumersOnMainThread(
-    const mojom::BatteryStatus& status) {
-  DCHECK(main_thread_task_runner_->BelongsToCurrentThread());
-  if (callback_list_.empty())
-    return;
-
-  status_ = status;
-  status_updated_ = true;
-  callback_list_.Notify(status_);
 }
 
 void BatteryStatusService::Shutdown() {
-  if (!callback_list_.empty())
-    battery_fetcher_->StopListeningBatteryChange();
-  battery_fetcher_.reset();
   is_shutdown_ = true;
 }
 
@@ -102,9 +57,6 @@ BatteryStatusService::GetUpdateCallbackForTesting() const {
 
 void BatteryStatusService::SetBatteryManagerForTesting(
     std::unique_ptr<BatteryStatusManager> test_battery_manager) {
-  battery_fetcher_ = std::move(test_battery_manager);
-  status_ = mojom::BatteryStatus();
-  status_updated_ = false;
   is_shutdown_ = false;
   main_thread_task_runner_ = base::SingleThreadTaskRunner::GetCurrentDefault();
 }
--- a/services/device/battery/battery_status_service.h
+++ b/services/device/battery/battery_status_service.h
@@ -59,15 +59,10 @@ class BatteryStatusService {
   // Updates current battery status and sends new status to interested
   // render processes. Can be called on any thread via a callback.
   void NotifyConsumers(const mojom::BatteryStatus& status);
-  void NotifyConsumersOnMainThread(const mojom::BatteryStatus& status);
-  void ConsumersChanged();
 
   scoped_refptr<base::SingleThreadTaskRunner> main_thread_task_runner_;
-  std::unique_ptr<BatteryStatusManager> battery_fetcher_;
   BatteryUpdateCallbackList callback_list_;
   BatteryUpdateCallback update_callback_;
-  mojom::BatteryStatus status_;
-  bool status_updated_;
   bool is_shutdown_;
 };
 
--- a/services/network/network_service_network_delegate.cc
+++ b/services/network/network_service_network_delegate.cc
@@ -8,6 +8,7 @@
 
 #include "base/debug/dump_without_crashing.h"
 #include "base/functional/bind.h"
+#include "base/command_line.h"
 #include "base/ranges/algorithm.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/types/optional_util.h"
@@ -65,6 +66,15 @@ void NetworkServiceNetworkDelegate::MaybeTruncateReferrer(
     return;
   }
 
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("referrer-directive")) {
+    std::string option = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("referrer-directive");
+    if (!url::IsSameOriginWith(effective_url, GURL(request->referrer())) || option == "noreferrers")
+      request->SetReferrer(std::string());
+    if (option == "minimal")
+      request->SetReferrer(url::Origin::Create(GURL(request->referrer())).GetURL().spec());
+    return;
+  }
+
   if (base::FeatureList::IsEnabled(
           net::features::kCapReferrerToOriginOnCrossOrigin)) {
     if (!url::IsSameOriginWith(effective_url, GURL(request->referrer()))) {
--- a/services/preferences/tracked/device_id_win.cc
+++ b/services/preferences/tracked/device_id_win.cc
@@ -10,11 +10,16 @@
 
 #include <memory>
 
+#include "base/command_line.h"
 #include "base/check.h"
 
 MachineIdStatus GetDeterministicMachineSpecificId(std::string* machine_id) {
   DCHECK(machine_id);
 
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("disable-machine-id")) {
+    return MachineIdStatus::NOT_IMPLEMENTED;
+  }
+
   wchar_t computer_name[MAX_COMPUTERNAME_LENGTH + 1] = {};
   DWORD computer_name_size = std::size(computer_name);
 
--- a/third_party/blink/common/features.cc
+++ b/third_party/blink/common/features.cc
@@ -31,6 +31,8 @@ BASE_FEATURE(kAttributionReportingCrossAppWeb,
              "AttributionReportingCrossAppWeb",
              base::FEATURE_DISABLED_BY_DEFAULT);
 
+BASE_FEATURE(kDisableLinkDrag, "DisableLinkDrag", base::FEATURE_DISABLED_BY_DEFAULT);
+
 // Apply lazy-loading to ad frames which have embeds likely impacting Core Web
 // Vitals.
 BASE_FEATURE(kAutomaticLazyFrameLoadingToAds,
@@ -501,7 +503,7 @@ BASE_FEATURE(kAllowSyncXHRInPageDismissal,
 // crbug.com/988956.
 BASE_FEATURE(kPrefetchPrivacyChanges,
              "PrefetchPrivacyChanges",
-             base::FEATURE_DISABLED_BY_DEFAULT);
+             base::FEATURE_ENABLED_BY_DEFAULT);
 
 // Decodes jpeg 4:2:0 formatted images to YUV instead of RGBX and stores in this
 // format in the image decode cache. See crbug.com/919627 for details on the
--- a/third_party/blink/common/mime_util/mime_util.cc
+++ b/third_party/blink/common/mime_util/mime_util.cc
@@ -82,6 +82,7 @@ static const char* const kUnsupportedTextTypes[] = {
     "text/x-csv",
     "text/x-vcf",
     "text/rtf",
+    "text/x-suse-ymp",
     "text/comma-separated-values",
     "text/csv",
     "text/tab-separated-values",
--- a/third_party/blink/public/common/features.h
+++ b/third_party/blink/public/common/features.h
@@ -18,6 +18,8 @@
 namespace blink {
 namespace features {
 
+BLINK_COMMON_EXPORT BASE_DECLARE_FEATURE(kDisableLinkDrag);
+
 BLINK_COMMON_EXPORT BASE_DECLARE_FEATURE(kAnonymousIframeOriginTrial);
 BLINK_COMMON_EXPORT BASE_DECLARE_FEATURE(kAttributionReportingCrossAppWeb);
 BLINK_COMMON_EXPORT BASE_DECLARE_FEATURE(kAutomaticLazyFrameLoadingToAds);
--- a/third_party/blink/public/platform/web_runtime_features.h
+++ b/third_party/blink/public/platform/web_runtime_features.h
@@ -68,6 +68,10 @@ class BLINK_PLATFORM_EXPORT WebRuntimeFeatures : public WebRuntimeFeaturesBase {
   static void EnableOverlayScrollbars(bool);
   static void EnableFluentScrollbars(bool);
 
+  static void EnableFingerprintingClientRectsNoise(bool);
+  static void EnableFingerprintingCanvasMeasureTextNoise(bool);
+  static void EnableFingerprintingCanvasImageDataNoise(bool);
+
   WebRuntimeFeatures() = delete;
 };
 
--- a/third_party/blink/renderer/bindings/scripts/generate_bindings.py
+++ b/third_party/blink/renderer/bindings/scripts/generate_bindings.py
@@ -11,6 +11,10 @@ import sys
 import web_idl
 import bind_gen
 
+# shutil.copy
+import shutil
+import os
+
 
 def parse_output_reldirs(reldirs):
     required = ['core', 'modules']
@@ -74,6 +78,11 @@ def parse_options(valid_tasks):
 
 
 def main():
+    # This fix build issue on Windows caused by missing google dependencies.
+    if os.name == 'nt':
+        if not os.path.exists('../../buildtools/win/clang-format.exe'):
+            shutil.copy('../../third_party/llvm-build/Release+Asserts/bin/clang-format.exe', '../../buildtools/win')
+
     dispatch_table = {
         'callback_function': bind_gen.generate_callback_functions,
         'callback_interface': bind_gen.generate_callback_interfaces,
--- a/third_party/blink/renderer/core/dom/document.cc
+++ b/third_party/blink/renderer/core/dom/document.cc
@@ -38,6 +38,7 @@
 #include "base/debug/dump_without_crashing.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/notreached.h"
+#include "base/rand_util.h"
 #include "base/ranges/algorithm.h"
 #include "base/time/time.h"
 #include "cc/animation/animation_host.h"
@@ -924,6 +925,14 @@ Range* Document::CreateRangeAdjustedToTreeScope(const TreeScope& tree_scope,
                                      Position::BeforeNode(*shadow_host));
 }
 
+double Document::GetNoiseFactorX() {
+  return noise_factor_x_;
+}
+
+double Document::GetNoiseFactorY() {
+  return noise_factor_y_;
+}
+
 SelectorQueryCache& Document::GetSelectorQueryCache() {
   if (!selector_query_cache_)
     selector_query_cache_ = std::make_unique<SelectorQueryCache>();
@@ -2249,6 +2258,15 @@ void Document::UpdateStyleAndLayoutTreeForThisDocument() {
 #if DCHECK_IS_ON()
   AssertLayoutTreeUpdated(*this, true /* allow_dirty_container_subtrees */);
 #endif
+
+  if (RuntimeEnabledFeatures::FingerprintingClientRectsNoiseEnabled()) {
+    // Precompute -0.0003% to 0.0003% noise factor for get*ClientRect*() fingerprinting
+    noise_factor_x_ = 1 + (base::RandDouble() - 0.5) * 0.000003;
+    noise_factor_y_ = 1 + (base::RandDouble() - 0.5) * 0.000003;
+  } else {
+    noise_factor_x_ = 1;
+    noise_factor_y_ = 1;
+  }
 }
 
 void Document::InvalidateStyleAndLayoutForFontUpdates() {
--- a/third_party/blink/renderer/core/dom/document.h
+++ b/third_party/blink/renderer/core/dom/document.h
@@ -513,6 +513,10 @@ class CORE_EXPORT Document : public ContainerNode,
     has_xml_declaration_ = has_xml_declaration ? 1 : 0;
   }
 
+  // Values for get*ClientRect fingerprint deception
+  double GetNoiseFactorX();
+  double GetNoiseFactorY();
+
   AtomicString visibilityState() const;
   bool IsPageVisible() const;
   bool hidden() const;
@@ -2335,6 +2339,9 @@ class CORE_EXPORT Document : public ContainerNode,
 
   base::ElapsedTimer start_time_;
 
+  double noise_factor_x_;
+  double noise_factor_y_;
+
   Member<ScriptRunner> script_runner_;
   Member<ScriptRunnerDelayer> script_runner_delayer_;
 
--- a/third_party/blink/renderer/core/dom/element.cc
+++ b/third_party/blink/renderer/core/dom/element.cc
@@ -2089,6 +2089,11 @@ DOMRectList* Element::getClientRects() {
   DCHECK(element_layout_object);
   GetDocument().AdjustQuadsForScrollAndAbsoluteZoom(quads,
                                                     *element_layout_object);
+  if (RuntimeEnabledFeatures::FingerprintingClientRectsNoiseEnabled()) {
+    for (gfx::QuadF& quad : quads) {
+      quad.Scale(GetDocument().GetNoiseFactorX(), GetDocument().GetNoiseFactorY());
+    }
+  }
   return MakeGarbageCollected<DOMRectList>(quads);
 }
 
@@ -2113,6 +2118,9 @@ gfx::RectF Element::GetBoundingClientRectNoLifecycleUpdate() const {
   DCHECK(element_layout_object);
   GetDocument().AdjustRectForScrollAndAbsoluteZoom(result,
                                                    *element_layout_object);
+  if (RuntimeEnabledFeatures::FingerprintingClientRectsNoiseEnabled()) {
+    result.Scale(GetDocument().GetNoiseFactorX(), GetDocument().GetNoiseFactorY());
+  }
   return result;
 }
 
--- a/third_party/blink/renderer/core/dom/range.cc
+++ b/third_party/blink/renderer/core/dom/range.cc
@@ -1612,11 +1612,21 @@ DOMRectList* Range::getClientRects() const {
   Vector<gfx::QuadF> quads;
   GetBorderAndTextQuads(quads);
 
+  if (RuntimeEnabledFeatures::FingerprintingClientRectsNoiseEnabled()) {
+    for (gfx::QuadF& quad : quads) {
+      quad.Scale(owner_document_->GetNoiseFactorX(), owner_document_->GetNoiseFactorY());
+    }
+  }
+
   return MakeGarbageCollected<DOMRectList>(quads);
 }
 
 DOMRect* Range::getBoundingClientRect() const {
-  return DOMRect::FromRectF(BoundingRect());
+  auto rect = BoundingRect();
+  if (RuntimeEnabledFeatures::FingerprintingClientRectsNoiseEnabled()) {
+    rect.Scale(owner_document_->GetNoiseFactorX(), owner_document_->GetNoiseFactorY());
+  }
+  return DOMRect::FromRectF(rect);
 }
 
 // TODO(editing-dev): We should make
--- a/third_party/blink/renderer/core/editing/selection_controller.cc
+++ b/third_party/blink/renderer/core/editing/selection_controller.cc
@@ -1385,10 +1385,14 @@ FrameSelection& SelectionController::Selection() const {
 }
 
 bool IsSelectionOverLink(const MouseEventWithHitTestResults& event) {
+if (base::FeatureList::IsEnabled(features::kDisableLinkDrag)){
+  return event.IsOverLink();
+}else{
   return (event.Event().GetModifiers() & WebInputEvent::Modifiers::kAltKey) !=
              0 &&
          event.IsOverLink();
 }
+}
 
 bool IsUserNodeDraggable(const MouseEventWithHitTestResults& event) {
   Node* inner_node = event.InnerNode();
--- a/third_party/blink/renderer/core/html/canvas/text_metrics.cc
+++ b/third_party/blink/renderer/core/html/canvas/text_metrics.cc
@@ -55,6 +55,24 @@ TextMetrics::TextMetrics(const Font& font,
   Update(font, direction, baseline, align, text);
 }
 
+void TextMetrics::Shuffle(const double factor) {
+  // x-direction
+  width_ *= factor;
+  actual_bounding_box_left_ *= factor;
+  actual_bounding_box_right_ *= factor;
+
+  // y-direction
+  font_bounding_box_ascent_ *= factor;
+  font_bounding_box_descent_ *= factor;
+  actual_bounding_box_ascent_ *= factor;
+  actual_bounding_box_descent_ *= factor;
+  em_height_ascent_ *= factor;
+  em_height_descent_ *= factor;
+  baselines_->setAlphabetic(baselines_->alphabetic() * factor);
+  baselines_->setHanging(baselines_->hanging() * factor);
+  baselines_->setIdeographic(baselines_->ideographic() * factor);
+}
+
 void TextMetrics::Update(const Font& font,
                          const TextDirection& direction,
                          const TextBaseline& baseline,
--- a/third_party/blink/renderer/core/html/canvas/text_metrics.h
+++ b/third_party/blink/renderer/core/html/canvas/text_metrics.h
@@ -64,6 +64,8 @@ class CORE_EXPORT TextMetrics final : public ScriptWrappable {
 
   void Trace(Visitor*) const override;
 
+  void Shuffle(const double factor);
+
  private:
   void Update(const Font&,
               const TextDirection&,
--- a/third_party/blink/renderer/core/input/mouse_event_manager.cc
+++ b/third_party/blink/renderer/core/input/mouse_event_manager.cc
@@ -663,8 +663,14 @@ WebInputEventResult MouseEventManager::HandleMousePressEvent(
 
   bool single_click = event.Event().click_count <= 1;
 
+if (base::FeatureList::IsEnabled(features::kDisableLinkDrag)){
+  mouse_down_may_start_drag_ = single_click && !IsSelectionOverLink(event) &&
+                               !IsExtendingSelection(event) &&
+			        !event.GetHitTestResult().IsSelected(event.GetHitTestLocation());
+}else{
   mouse_down_may_start_drag_ = single_click && !IsSelectionOverLink(event) &&
                                !IsExtendingSelection(event);
+}
 
   mouse_down_ = event.Event();
 
--- a/third_party/blink/renderer/core/xml/parser/xml_document_parser.cc
+++ b/third_party/blink/renderer/core/xml/parser/xml_document_parser.cc
@@ -142,11 +142,11 @@ class PendingStartElementNSCallback final
         attribute_count_(attribute_count),
         defaulted_count_(defaulted_count) {
     namespaces_ = static_cast<xmlChar**>(
-        xmlMalloc(sizeof(xmlChar*) * namespace_count * 2));
+        malloc(sizeof(xmlChar*) * namespace_count * 2));
     for (int i = 0; i < namespace_count * 2; ++i)
       namespaces_[i] = xmlStrdup(namespaces[i]);
     attributes_ = static_cast<xmlChar**>(
-        xmlMalloc(sizeof(xmlChar*) * attribute_count * 5));
+        malloc(sizeof(xmlChar*) * attribute_count * 5));
     for (int i = 0; i < attribute_count; ++i) {
       // Each attribute has 5 elements in the array:
       // name, prefix, uri, value and an end pointer.
@@ -161,12 +161,12 @@ class PendingStartElementNSCallback final
 
   ~PendingStartElementNSCallback() override {
     for (int i = 0; i < namespace_count_ * 2; ++i)
-      xmlFree(namespaces_[i]);
-    xmlFree(namespaces_);
+      free(namespaces_[i]);
+    free(namespaces_);
     for (int i = 0; i < attribute_count_; ++i)
       for (int j = 0; j < 4; ++j)
-        xmlFree(attributes_[i * 5 + j]);
-    xmlFree(attributes_);
+        free(attributes_[i * 5 + j]);
+    free(attributes_);
   }
 
   void Call(XMLDocumentParser* parser) override {
@@ -214,7 +214,7 @@ class PendingCharactersCallback final
         chars_(xmlStrndup(chars, length)),
         length_(length) {}
 
-  ~PendingCharactersCallback() override { xmlFree(chars_); }
+  ~PendingCharactersCallback() override { free(chars_); }
 
   void Call(XMLDocumentParser* parser) override {
     parser->Characters(chars_, length_);
@@ -298,7 +298,7 @@ class PendingErrorCallback final : public XMLDocumentParser::PendingCallback {
         type_(type),
         message_(xmlStrdup(message)) {}
 
-  ~PendingErrorCallback() override { xmlFree(message_); }
+  ~PendingErrorCallback() override { free(message_); }
 
   void Call(XMLDocumentParser* parser) override {
     parser->HandleError(type_, reinterpret_cast<char*>(message_),
--- a/third_party/blink/renderer/core/xml/xsl_style_sheet_libxslt.cc
+++ b/third_party/blink/renderer/core/xml/xsl_style_sheet_libxslt.cc
@@ -190,7 +190,7 @@ void XSLStyleSheet::LoadChildSheets() {
         xmlChar* uri_ref =
             xsltGetNsProp(curr, (const xmlChar*)"href", XSLT_NAMESPACE);
         LoadChildSheet(String::FromUTF8((const char*)uri_ref));
-        xmlFree(uri_ref);
+        free(uri_ref);
       } else {
         break;
       }
@@ -204,7 +204,7 @@ void XSLStyleSheet::LoadChildSheets() {
         xmlChar* uri_ref =
             xsltGetNsProp(curr, (const xmlChar*)"href", XSLT_NAMESPACE);
         LoadChildSheet(String::FromUTF8((const char*)uri_ref));
-        xmlFree(uri_ref);
+        free(uri_ref);
       }
       curr = curr->next;
     }
@@ -294,8 +294,8 @@ xmlDocPtr XSLStyleSheet::LocateStylesheetSubResource(xmlDocPtr parent_doc,
       xmlChar* child_uri =
           xmlBuildURI((const xmlChar*)import_href.c_str(), base);
       bool equal_ur_is = xmlStrEqual(uri, child_uri);
-      xmlFree(base);
-      xmlFree(child_uri);
+      free(base);
+      free(child_uri);
       if (equal_ur_is) {
         child->MarkAsProcessed();
         return child->GetDocument();
--- a/third_party/blink/renderer/core/xml/xslt_extensions.cc
+++ b/third_party/blink/renderer/core/xml/xslt_extensions.cc
@@ -69,7 +69,7 @@ static void ExsltNodeSetFunction(xmlXPathParserContextPtr ctxt, int nargs) {
   CHECK(ret);
 
   if (strval)
-    xmlFree(strval);
+    free(strval);
 
   valuePush(ctxt, ret);
 }
--- a/third_party/blink/renderer/core/xml/xslt_processor_libxslt.cc
+++ b/third_party/blink/renderer/core/xml/xslt_processor_libxslt.cc
@@ -110,7 +110,7 @@ static xmlDocPtr DocLoaderFunc(const xmlChar* uri,
       xmlChar* base = xmlNodeGetBase(context->document->doc, context->node);
       KURL url(KURL(reinterpret_cast<const char*>(base)),
                reinterpret_cast<const char*>(uri));
-      xmlFree(base);
+      free(base);
 
       ResourceLoaderOptions fetch_options(nullptr /* world */);
       fetch_options.initiator_info.name = fetch_initiator_type_names::kXml;
--- a/third_party/blink/renderer/core/xml/xslt_unicode_sort.cc
+++ b/third_party/blink/renderer/core/xml/xslt_unicode_sort.cc
@@ -327,18 +327,18 @@ void XsltUnicodeSortFunction(xsltTransformContextPtr ctxt,
     comp = static_cast<xsltStylePreComp*>(sorts[j]->psvi);
     if (tempstype[j] == 1) {
       // The data-type needs to be recomputed each time.
-      xmlFree(const_cast<xmlChar*>(comp->stype));
+      free(const_cast<xmlChar*>(comp->stype));
       comp->stype = nullptr;
     }
     if (temporder[j] == 1) {
       // The order needs to be recomputed each time.
-      xmlFree(const_cast<xmlChar*>(comp->order));
+      free(const_cast<xmlChar*>(comp->order));
       comp->order = nullptr;
     }
     if (results_tab[j]) {
       for (int i = 0; i < len; ++i)
         xmlXPathFreeObject(results_tab[j][i]);
-      xmlFree(results_tab[j]);
+      free(results_tab[j]);
     }
   }
 
--- a/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc
+++ b/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc
@@ -32,6 +32,7 @@
 #include "third_party/blink/renderer/platform/graphics/bitmap_image.h"
 #include "third_party/blink/renderer/platform/graphics/graphics_context.h"
 #include "third_party/blink/renderer/platform/graphics/skia/skia_utils.h"
+#include "third_party/blink/renderer/platform/graphics/static_bitmap_image.h"
 #include "third_party/blink/renderer/platform/graphics/stroke_data.h"
 #include "third_party/blink/renderer/platform/graphics/video_frame_image_util.h"
 #include "third_party/blink/renderer/platform/heap/garbage_collected.h"
@@ -2057,6 +2058,9 @@ ImageData* BaseRenderingContext2D::getImageDataInternal(
           snapshot->PaintImageForCurrentFrame().GetSkImageInfo().bounds();
       DCHECK(!bounds.intersect(SkIRect::MakeXYWH(sx, sy, sw, sh)));
     }
+    if (read_pixels_successful && RuntimeEnabledFeatures::FingerprintingCanvasImageDataNoiseEnabled()) {
+      StaticBitmapImage::ShuffleSubchannelColorData(image_data_pixmap.addr(), image_data_pixmap.info(), sx, sy);
+    }
   }
 
   return image_data;
--- a/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc
+++ b/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc
@@ -938,9 +938,15 @@ TextMetrics* CanvasRenderingContext2D::measureText(const String& text) {
   TextDirection direction =
       ToTextDirection(GetState().GetDirection(), canvas());
 
-  return MakeGarbageCollected<TextMetrics>(font, direction,
+  TextMetrics* text_metrics = MakeGarbageCollected<TextMetrics>(font, direction,
                                            GetState().GetTextBaseline(),
                                            GetState().GetTextAlign(), text);
+
+  // Scale text metrics if enabled
+  if (RuntimeEnabledFeatures::FingerprintingCanvasMeasureTextNoiseEnabled()) {
+    text_metrics->Shuffle(canvas()->GetDocument().GetNoiseFactorX());
+  }
+  return text_metrics;
 }
 
 void CanvasRenderingContext2D::drawFormattedText(
--- a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
+++ b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
@@ -3703,8 +3703,7 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
               pname, IdentifiabilityBenignStringToken(
                          String(ContextGL()->GetString(GL_RENDERER))));
         }
-        return WebGLAny(script_state,
-                        String(ContextGL()->GetString(GL_RENDERER)));
+        return WebGLAny(script_state, String(""));
       }
       SynthesizeGLError(
           GL_INVALID_ENUM, "getParameter",
@@ -3718,8 +3717,7 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
               pname, IdentifiabilityBenignStringToken(
                          String(ContextGL()->GetString(GL_VENDOR))));
         }
-        return WebGLAny(script_state,
-                        String(ContextGL()->GetString(GL_VENDOR)));
+        return WebGLAny(script_state, String(""));
       }
       SynthesizeGLError(
           GL_INVALID_ENUM, "getParameter",
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -1641,7 +1641,9 @@ component("platform") {
     "//third_party/blink/renderer:non_test_config",
   ]
 
-  include_dirs = []
+  include_dirs = [
+    "//third_party/skia/include/private", # For shuffler in graphics/static_bitmap_image.cc
+  ]
 
   allow_circular_includes_from = [
     "//third_party/blink/renderer/platform/blob",
@@ -1683,6 +1685,7 @@ component("platform") {
     "//components/paint_preview/common",
     "//components/power_scheduler",
     "//components/search_engines:search_engine_utils",
+    "//components/croma:croma_switches",
     "//components/viz/client",
     "//components/viz/common",
     "//components/webrtc:net_address_utils",
--- a/third_party/blink/renderer/platform/exported/web_runtime_features.cc
+++ b/third_party/blink/renderer/platform/exported/web_runtime_features.cc
@@ -65,4 +65,16 @@ void WebRuntimeFeatures::EnableFluentScrollbars(bool enable) {
   ScrollbarThemeSettings::SetFluentScrollbarsEnabled(enable);
 }
 
+void WebRuntimeFeatures::EnableFingerprintingClientRectsNoise(bool enable) {
+  RuntimeEnabledFeatures::SetFingerprintingClientRectsNoiseEnabled(enable);
+}
+
+void WebRuntimeFeatures::EnableFingerprintingCanvasMeasureTextNoise(bool enable) {
+  RuntimeEnabledFeatures::SetFingerprintingCanvasMeasureTextNoiseEnabled(enable);
+}
+
+void WebRuntimeFeatures::EnableFingerprintingCanvasImageDataNoise(bool enable) {
+  RuntimeEnabledFeatures::SetFingerprintingCanvasImageDataNoiseEnabled(enable);
+}
+
 }  // namespace blink
--- a/third_party/blink/renderer/platform/graphics/image_data_buffer.cc
+++ b/third_party/blink/renderer/platform/graphics/image_data_buffer.cc
@@ -36,6 +36,8 @@
 
 #include "base/compiler_specific.h"
 #include "base/memory/ptr_util.h"
+#include "base/rand_util.h"
+#include "base/logging.h"
 #include "third_party/blink/renderer/platform/graphics/static_bitmap_image.h"
 #include "third_party/blink/renderer/platform/image-encoders/image_encoder.h"
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
@@ -145,6 +147,11 @@ bool ImageDataBuffer::EncodeImageInternal(const ImageEncodingMimeType mime_type,
                                           const SkPixmap& pixmap) const {
   DCHECK(is_valid_);
 
+  if (RuntimeEnabledFeatures::FingerprintingCanvasImageDataNoiseEnabled()) {
+    // shuffle subchannel color data within the pixmap
+    StaticBitmapImage::ShuffleSubchannelColorData(pixmap_.writable_addr(), pixmap_.info(), 0, 0);
+  }
+
   if (mime_type == kMimeTypeJpeg) {
     SkJpegEncoder::Options options;
     options.fQuality = ImageEncoder::ComputeJpegQuality(quality);
--- a/third_party/blink/renderer/platform/graphics/static_bitmap_image.cc
+++ b/third_party/blink/renderer/platform/graphics/static_bitmap_image.cc
@@ -4,6 +4,8 @@
 
 #include "third_party/blink/renderer/platform/graphics/static_bitmap_image.h"
 
+#include "base/rand_util.h"
+#include "base/logging.h"
 #include "base/numerics/checked_math.h"
 #include "gpu/command_buffer/client/gles2_interface.h"
 #include "third_party/blink/renderer/platform/graphics/accelerated_static_bitmap_image.h"
@@ -11,10 +13,12 @@
 #include "third_party/blink/renderer/platform/graphics/image_observer.h"
 #include "third_party/blink/renderer/platform/graphics/paint/paint_image.h"
 #include "third_party/blink/renderer/platform/graphics/unaccelerated_static_bitmap_image.h"
+#include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/skia/include/core/SkCanvas.h"
 #include "third_party/skia/include/core/SkImage.h"
 #include "third_party/skia/include/core/SkPaint.h"
 #include "third_party/skia/include/core/SkSurface.h"
+#include "third_party/skia/include/private/SkColorData.h"
 #include "ui/gfx/geometry/skia_conversions.h"
 #include "v8/include/v8.h"
 
@@ -115,4 +119,154 @@ void StaticBitmapImage::DrawHelper(cc::PaintCanvas* canvas,
       WebCoreClampingModeToSkiaRectConstraint(draw_options.clamping_mode));
 }
 
+// set the component to maximum-delta if it is >= maximum, or add to existing color component (color + delta)
+#define shuffleComponent(color, max, delta) ( (color) >= (max) ? ((max)-(delta)) : ((color)+(delta)) )
+
+#define writable_addr(T, p, stride, x, y) (T*)((const char *)p + y * stride + x * sizeof(T))
+
+void StaticBitmapImage::ShuffleSubchannelColorData(const void *addr, const SkImageInfo& info, int srcX, int srcY) {
+  auto w = info.width() - srcX, h = info.height() - srcY;
+
+  // skip tiny images; info.width()/height() can also be 0
+  if ((w < 8) || (h < 8)) {
+    return;
+  }
+
+  // generate the first random number here
+  double shuffleX = base::RandDouble();
+
+  // cap maximum pixels to change
+  auto pixels = (w + h) / 128;
+  if (pixels > 10) {
+    pixels = 10;
+  } else if (pixels < 2) {
+    pixels = 2;
+  }
+
+  auto colorType = info.colorType();
+  auto fRowBytes = info.minRowBytes(); // stride
+
+  DLOG(INFO) << "BRM: ShuffleSubchannelColorData() w=" << w << " h=" << h << " colorType=" << colorType << " fRowBytes=" << fRowBytes;
+
+  // second random number (for y/height)
+  double shuffleY = base::RandDouble();
+
+  // calculate random coordinates using bisection
+  auto currentW = w, currentH = h;
+  for(;pixels >= 0; pixels--) {
+    int x = currentW * shuffleX, y = currentH * shuffleY;
+
+    // calculate randomisation amounts for each RGB component
+    uint8_t shuffleR = base::RandInt(0, 4);
+    uint8_t shuffleG = (shuffleR + x) % 4;
+    uint8_t shuffleB = (shuffleG + y) % 4;
+
+    // manipulate pixel data to slightly change the R, G, B components
+    switch (colorType) {
+      case kAlpha_8_SkColorType:
+      {
+         auto *pixel = writable_addr(uint8_t, addr, fRowBytes, x, y);
+         auto r = SkColorGetR(*pixel), g = SkColorGetG(*pixel), b = SkColorGetB(*pixel), a = SkColorGetA(*pixel);
+
+         r = shuffleComponent(r, UINT8_MAX-1, shuffleR);
+         g = shuffleComponent(g, UINT8_MAX-1, shuffleG);
+         b = shuffleComponent(b, UINT8_MAX-1, shuffleB);
+         // alpha is left unchanged
+
+         *pixel = SkColorSetARGB(a, r, g, b);
+      }
+      break;
+      case kGray_8_SkColorType:
+      {
+         auto *pixel = writable_addr(uint8_t, addr, fRowBytes, x, y);
+         *pixel = shuffleComponent(*pixel, UINT8_MAX-1, shuffleB);
+      }
+      break;
+      case kRGB_565_SkColorType:
+      {
+         auto *pixel = writable_addr(uint16_t, addr, fRowBytes, x, y);
+         unsigned    r = SkPacked16ToR32(*pixel);
+         unsigned    g = SkPacked16ToG32(*pixel);
+         unsigned    b = SkPacked16ToB32(*pixel);
+
+         r = shuffleComponent(r, 31, shuffleR);
+         g = shuffleComponent(g, 63, shuffleG);
+         b = shuffleComponent(b, 31, shuffleB);
+
+         unsigned r16 = (r & SK_R16_MASK) << SK_R16_SHIFT;
+         unsigned g16 = (g & SK_G16_MASK) << SK_G16_SHIFT;
+         unsigned b16 = (b & SK_B16_MASK) << SK_B16_SHIFT;
+
+         *pixel = r16 | g16 | b16;
+      }
+      break;
+      case kARGB_4444_SkColorType:
+      {
+         auto *pixel = writable_addr(uint16_t, addr, fRowBytes, x, y);
+         auto a = SkGetPackedA4444(*pixel), r = SkGetPackedR4444(*pixel), g = SkGetPackedG4444(*pixel), b = SkGetPackedB4444(*pixel);
+
+         r = shuffleComponent(r, 15, shuffleR);
+         g = shuffleComponent(g, 15, shuffleG);
+         b = shuffleComponent(b, 15, shuffleB);
+         // alpha is left unchanged
+
+         unsigned a4 = (a & 0xF) << SK_A4444_SHIFT;
+         unsigned r4 = (r & 0xF) << SK_R4444_SHIFT;
+         unsigned g4 = (g & 0xF) << SK_G4444_SHIFT;
+         unsigned b4 = (b & 0xF) << SK_B4444_SHIFT;
+
+         *pixel = r4 | b4 | g4 | a4;
+      }
+      break;
+      case kRGBA_8888_SkColorType:
+      {
+         auto *pixel = writable_addr(uint32_t, addr, fRowBytes, x, y);
+         auto a = SkGetPackedA32(*pixel), r = SkGetPackedR32(*pixel), g = SkGetPackedG32(*pixel), b = SkGetPackedB32(*pixel);
+
+         r = shuffleComponent(r, UINT8_MAX-1, shuffleR);
+         g = shuffleComponent(g, UINT8_MAX-1, shuffleG);
+         b = shuffleComponent(b, UINT8_MAX-1, shuffleB);
+         // alpha is left unchanged
+
+         *pixel = (a << SK_A32_SHIFT) | (r << SK_R32_SHIFT) |
+                  (g << SK_G32_SHIFT) | (b << SK_B32_SHIFT);
+      }
+      break;
+      case kBGRA_8888_SkColorType:
+      {
+         auto *pixel = writable_addr(uint32_t, addr, fRowBytes, x, y);
+         auto a = SkGetPackedA32(*pixel), b = SkGetPackedR32(*pixel), g = SkGetPackedG32(*pixel), r = SkGetPackedB32(*pixel);
+
+         r = shuffleComponent(r, UINT8_MAX-1, shuffleR);
+         g = shuffleComponent(g, UINT8_MAX-1, shuffleG);
+         b = shuffleComponent(b, UINT8_MAX-1, shuffleB);
+         // alpha is left unchanged
+
+         *pixel = (a << SK_BGRA_A32_SHIFT) | (r << SK_BGRA_R32_SHIFT) |
+                  (g << SK_BGRA_G32_SHIFT) | (b << SK_BGRA_B32_SHIFT);
+      }
+      break;
+      default:
+         // the remaining formats are not expected to be used in Chromium
+         LOG(WARNING) << "BRM: ShuffleSubchannelColorData(): Ignoring pixel format";
+         return;
+    }
+
+    // keep bisecting or reset current width/height as needed
+    if (x == 0) {
+       currentW = w;
+    } else {
+       currentW = x;
+    }
+    if (y == 0) {
+       currentH = h;
+    } else {
+       currentH = y;
+    }
+  }
+}
+
+#undef writable_addr
+#undef shuffleComponent
+
 }  // namespace blink
--- a/third_party/blink/renderer/platform/graphics/static_bitmap_image.h
+++ b/third_party/blink/renderer/platform/graphics/static_bitmap_image.h
@@ -37,6 +37,8 @@ class PLATFORM_EXPORT StaticBitmapImage : public Image {
 
   StaticBitmapImage(ImageOrientation orientation) : orientation_(orientation) {}
 
+  static void ShuffleSubchannelColorData(const void *addr, const SkImageInfo& info, int srcX, int srcY);
+
   bool IsStaticBitmapImage() const override { return true; }
 
   // Methods overridden by all sub-classes
--- a/third_party/blink/renderer/platform/runtime_enabled_features.json5
+++ b/third_party/blink/renderer/platform/runtime_enabled_features.json5
@@ -1328,6 +1328,15 @@
       status: "experimental",
       origin_trial_feature_name: "Focusgroup",
     },
+    {
+      name: "FingerprintingClientRectsNoise",
+    },
+    {
+      name: "FingerprintingCanvasMeasureTextNoise",
+    },
+    {
+      name: "FingerprintingCanvasImageDataNoise",
+    },
     {
       name: "FocuslessSpatialNavigation",
       settable_from_internals: true,
--- a/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
+++ b/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
@@ -735,8 +735,6 @@ void CrashpadClient::CrashWithoutDump(const std::string& message) {
 // static
 void CrashpadClient::SetFirstChanceExceptionHandler(
     FirstChanceHandler handler) {
-  DCHECK(SignalHandler::Get());
-  SignalHandler::Get()->SetFirstChanceHandler(handler);
 }
 
 void CrashpadClient::SetUnhandledSignals(const std::set<int>& signals) {
--- a/third_party/libxml/chromium/xml_reader.cc
+++ b/third_party/libxml/chromium/xml_reader.cc
@@ -17,7 +17,7 @@ namespace {
 // Same as XmlStringToStdString but also frees |xmlstring|.
 std::string XmlStringToStdStringWithDelete(xmlChar* xmlstring) {
   std::string result = XmlStringToStdString(xmlstring);
-  xmlFree(xmlstring);
+  free(xmlstring);
   return result;
 }
 
--- a/tools/gn/bootstrap/bootstrap.py
+++ b/tools/gn/bootstrap/bootstrap.py
@@ -69,7 +69,7 @@ def main(argv):
   else:
     build_rel = os.path.join('out', 'Release')
   out_dir = os.path.join(SRC_ROOT, build_rel)
-  gn_path = options.output or os.path.join(out_dir, 'gn')
+  gn_path = options.output or os.path.join(out_dir, 'gn.exe')
   gn_build_dir = os.path.join(out_dir, 'gn_build')
   ninja_binary = os.environ.get('NINJA', 'ninja')
 
@@ -123,11 +123,13 @@ def main(argv):
 
   shutil.copy2(
       os.path.join(BOOTSTRAP_DIR, 'last_commit_position.h'), gn_build_dir)
-  cmd = [ninja_binary, '-C', gn_build_dir, '-w', 'dupbuild=err', 'gn']
   if options.jobs:
-    cmd += ['-j', str(options.jobs)]
-  subprocess.check_call(cmd)
-  shutil.copy2(os.path.join(gn_build_dir, 'gn'), gn_path)
+    subprocess.check_call(
+        [ninja_binary, '-C', gn_build_dir, '-w', 'dupbuild=err', '-j'+str(options.jobs), 'gn.exe'])
+  else:
+    subprocess.check_call(
+        [ninja_binary, '-C', gn_build_dir, '-w', 'dupbuild=err', 'gn.exe'])
+  shutil.copy2(os.path.join(gn_build_dir, 'gn.exe'), gn_path)
 
   if not options.skip_generate_buildfiles:
     gn_gen_args = options.gn_gen_args or ''
--- a/tools/gn/build/build_win.ninja.template
+++ b/tools/gn/build/build_win.ninja.template
@@ -1,5 +1,5 @@
 rule cxx
-  command = $cxx /nologo /showIncludes /FC $includes $cflags /c $in /Fo$out
+  command = $cxx /utf-8 /nologo /showIncludes /FC $includes $cflags /c $in /Fo$out
   description = CXX $out
   deps = msvc
 
--- a/tools/licenses/licenses.py
+++ b/tools/licenses/licenses.py
@@ -622,7 +622,7 @@ def _GnBinary():
   elif sys.platform == 'darwin':
     subdir = 'mac'
   elif sys.platform == 'win32':
-    subdir, exe = 'win', 'gn.exe'
+    subdir, exe = os.path.join('..', 'out', 'Release', 'gn_build'), 'gn.exe'
   else:
     raise RuntimeError("Unsupported platform '%s'." % sys.platform)
 
--- a/tools/perf/chrome_telemetry_build/BUILD.gn
+++ b/tools/perf/chrome_telemetry_build/BUILD.gn
@@ -41,10 +41,6 @@ group("telemetry_chrome_test") {
     data_deps += [ "//chrome" ]
   }
 
-  if (is_win) {
-    data_deps += [ "//chrome:reorder_imports" ]
-  }
-
   if (is_linux || is_chromeos) {
     data_deps += [ "//third_party/breakpad:dump_syms($host_toolchain)" ]
 
--- a/tools/resources/generate_resource_allowlist.py
+++ b/tools/resources/generate_resource_allowlist.py
@@ -61,7 +61,7 @@ def GetResourceAllowlistPDB(path):
   pdbutil = subprocess.Popen(
       [os.path.join(llvm_bindir, 'llvm-pdbutil'), 'dump', '-publics', path],
       stdout=subprocess.PIPE)
-  names = ''
+  names = set()
   for line in pdbutil.stdout:
     line = line.decode('utf8')
     # Read a line of the form
@@ -75,31 +75,35 @@ def GetResourceAllowlistPDB(path):
     # Example: __profd_??$AllowlistedResource@$0BGPH@@ui@@YAXXZ
     # C++ mangled names are supposed to begin with `?`, so check for that.
     if 'AllowlistedResource' in sym_name and sym_name.startswith('?'):
-      names += sym_name + '\n'
+      names.add(sym_name)
   exit_code = pdbutil.wait()
   if exit_code != 0:
     raise Exception('llvm-pdbutil exited with exit code %d' % exit_code)
 
-  undname = subprocess.Popen([os.path.join(llvm_bindir, 'llvm-undname')],
-                             stdin=subprocess.PIPE,
-                             stdout=subprocess.PIPE)
-  stdout, _ = undname.communicate(names.encode('utf8'))
   resource_ids = set()
-  for line in stdout.split(b'\n'):
-    line = line.decode('utf8')
-    # Read a line of the form
-    # "void __cdecl ui::AllowlistedResource<5484>(void)".
-    prefix = ' ui::AllowlistedResource<'
-    pos = line.find(prefix)
-    if pos == -1:
-      continue
-    try:
-      resource_ids.add(int(line[pos + len(prefix):line.rfind('>')]))
-    except ValueError:
-      continue
-  exit_code = undname.wait()
-  if exit_code != 0:
-    raise Exception('llvm-undname exited with exit code %d' % exit_code)
+  for name in names:
+    undname = subprocess.Popen(['undname', name],
+                               stdout=subprocess.PIPE)
+    found = False
+    for line in undname.stdout:
+      line = line.decode('utf8')
+      # Read a line of the form
+      # "void __cdecl ui::AllowlistedResource<5484>(void)".
+      prefix = ' ui::AllowlistedResource<'
+      pos = line.find(prefix)
+      if pos == -1:
+        continue
+      try:
+        resource_ids.add(int(line[pos + len(prefix):line.rfind('>')]))
+      except ValueError:
+        continue
+      found = True
+      break
+    exit_code = undname.wait()
+    if exit_code != 0:
+      raise Exception('llvm-undname exited with exit code %d' % exit_code)
+    if not found:
+      raise Exception('Unexpected undname output')
   return resource_ids
 
 
--- a/ui/base/mojom/window_open_disposition_mojom_traits.h
+++ b/ui/base/mojom/window_open_disposition_mojom_traits.h
@@ -5,6 +5,7 @@
 #ifndef UI_BASE_MOJOM_WINDOW_OPEN_DISPOSITION_MOJOM_TRAITS_H_
 #define UI_BASE_MOJOM_WINDOW_OPEN_DISPOSITION_MOJOM_TRAITS_H_
 
+#include "base/command_line.h"
 #include "base/notreached.h"
 #include "mojo/public/cpp/bindings/enum_traits.h"
 #include "ui/base/mojom/window_open_disposition.mojom.h"
@@ -30,6 +31,8 @@ struct EnumTraits<ui::mojom::WindowOpenDisposition, WindowOpenDisposition> {
       case WindowOpenDisposition::NEW_PICTURE_IN_PICTURE:
         return ui::mojom::WindowOpenDisposition::NEW_PICTURE_IN_PICTURE;
       case WindowOpenDisposition::NEW_POPUP:
+        if (base::CommandLine::ForCurrentProcess()->HasSwitch("popups-to-tabs"))
+          return ui::mojom::WindowOpenDisposition::NEW_FOREGROUND_TAB;
         return ui::mojom::WindowOpenDisposition::NEW_POPUP;
       case WindowOpenDisposition::NEW_WINDOW:
         return ui::mojom::WindowOpenDisposition::NEW_WINDOW;
@@ -68,6 +71,8 @@ struct EnumTraits<ui::mojom::WindowOpenDisposition, WindowOpenDisposition> {
         return true;
       case ui::mojom::WindowOpenDisposition::NEW_POPUP:
         *out = WindowOpenDisposition::NEW_POPUP;
+        if (base::CommandLine::ForCurrentProcess()->HasSwitch("popups-to-tabs"))
+          *out = WindowOpenDisposition::NEW_FOREGROUND_TAB;
         return true;
       case ui::mojom::WindowOpenDisposition::NEW_WINDOW:
         *out = WindowOpenDisposition::NEW_WINDOW;
